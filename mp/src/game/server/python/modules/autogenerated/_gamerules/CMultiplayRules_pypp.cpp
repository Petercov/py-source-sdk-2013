// This file has been generated by Py++.

#include "cbase.h"
// This file has been generated by Py++.

#include "cbase.h"
#include "gamerules.h"
#include "multiplay_gamerules.h"
#include "singleplay_gamerules.h"
#include "teamplay_gamerules.h"
#include "srcpy_gamerules.h"
#include "hl2mp/hl2mp_player.h"
#include "hl2mp/hl2mp_gamerules.h"
#include "ammodef.h"
#include "items.h"
#include "tier0/valve_minmax_off.h"
#include "srcpy.h"
#include "tier0/valve_minmax_on.h"
#include "tier0/memdbgon.h"
#include "CMultiplayRules_pypp.hpp"

namespace bp = boost::python;

struct CMultiplayRules_wrapper : CMultiplayRules, bp::wrapper< CMultiplayRules > {

    CMultiplayRules_wrapper( )
    : CMultiplayRules( )
      , bp::wrapper< CMultiplayRules >(){
        // null constructor
    
    }

    virtual bool AllowAutoTargetCrosshair(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AllowAutoTargetCrosshair: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AllowAutoTargetCrosshair(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AllowAutoTargetCrosshair = this->get_override( "AllowAutoTargetCrosshair" );
        if( func_AllowAutoTargetCrosshair.ptr() != Py_None )
            try {
                return func_AllowAutoTargetCrosshair(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::AllowAutoTargetCrosshair(  );
            }
        else
            return this->CMultiplayRules::AllowAutoTargetCrosshair(  );
    }
    
    bool default_AllowAutoTargetCrosshair(  ) {
        return CMultiplayRules::AllowAutoTargetCrosshair( );
    }

    virtual bool AllowDamage( ::CBaseEntity * pVictim, ::CTakeDamageInfo const & info ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AllowDamage: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AllowDamage( boost::python::ptr(pVictim), boost::ref(info) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AllowDamage = this->get_override( "AllowDamage" );
        if( func_AllowDamage.ptr() != Py_None )
            try {
                return func_AllowDamage( boost::python::ptr(pVictim), boost::ref(info) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::AllowDamage( boost::python::ptr(pVictim), boost::ref(info) );
            }
        else
            return this->CMultiplayRules::AllowDamage( boost::python::ptr(pVictim), boost::ref(info) );
    }
    
    bool default_AllowDamage( ::CBaseEntity * pVictim, ::CTakeDamageInfo const & info ) {
        return CMultiplayRules::AllowDamage( boost::python::ptr(pVictim), boost::ref(info) );
    }

    virtual bool CanHaveItem( ::CBasePlayer * pPlayer, ::CItem * pItem ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "CanHaveItem: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling CanHaveItem( boost::python::ptr(pPlayer), boost::python::ptr(pItem) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_CanHaveItem = this->get_override( "CanHaveItem" );
        if( func_CanHaveItem.ptr() != Py_None )
            try {
                return func_CanHaveItem( boost::python::ptr(pPlayer), boost::python::ptr(pItem) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::CanHaveItem( boost::python::ptr(pPlayer), boost::python::ptr(pItem) );
            }
        else
            return this->CMultiplayRules::CanHaveItem( boost::python::ptr(pPlayer), boost::python::ptr(pItem) );
    }
    
    bool default_CanHaveItem( ::CBasePlayer * pPlayer, ::CItem * pItem ) {
        return CMultiplayRules::CanHaveItem( boost::python::ptr(pPlayer), boost::python::ptr(pItem) );
    }

    virtual bool CanHavePlayerItem( ::CBasePlayer * pPlayer, ::CBaseCombatWeapon * pWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "CanHavePlayerItem: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling CanHavePlayerItem( boost::python::ptr(pPlayer), boost::python::ptr(pWeapon) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_CanHavePlayerItem = this->get_override( "CanHavePlayerItem" );
        if( func_CanHavePlayerItem.ptr() != Py_None )
            try {
                return func_CanHavePlayerItem( boost::python::ptr(pPlayer), boost::python::ptr(pWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::CanHavePlayerItem( boost::python::ptr(pPlayer), boost::python::ptr(pWeapon) );
            }
        else
            return this->CMultiplayRules::CanHavePlayerItem( boost::python::ptr(pPlayer), boost::python::ptr(pWeapon) );
    }
    
    bool default_CanHavePlayerItem( ::CBasePlayer * pPlayer, ::CBaseCombatWeapon * pWeapon ) {
        return CMultiplayRules::CanHavePlayerItem( boost::python::ptr(pPlayer), boost::python::ptr(pWeapon) );
    }

    virtual void ChangeLevel(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ChangeLevel: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ChangeLevel(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ChangeLevel = this->get_override( "ChangeLevel" );
        if( func_ChangeLevel.ptr() != Py_None )
            try {
                func_ChangeLevel(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::ChangeLevel(  );
            }
        else
            this->CMultiplayRules::ChangeLevel(  );
    }
    
    void default_ChangeLevel(  ) {
        CMultiplayRules::ChangeLevel( );
    }

    virtual bool ClientCommand( ::CBaseEntity * pEdict, ::CCommand const & args ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientCommand: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ClientCommand( boost::python::ptr(pEdict), boost::ref(args) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientCommand = this->get_override( "ClientCommand" );
        if( func_ClientCommand.ptr() != Py_None )
            try {
                return func_ClientCommand( boost::python::ptr(pEdict), boost::ref(args) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::ClientCommand( boost::python::ptr(pEdict), boost::ref(args) );
            }
        else
            return this->CMultiplayRules::ClientCommand( boost::python::ptr(pEdict), boost::ref(args) );
    }
    
    bool default_ClientCommand( ::CBaseEntity * pEdict, ::CCommand const & args ) {
        return CMultiplayRules::ClientCommand( boost::python::ptr(pEdict), boost::ref(args) );
    }

    virtual void ClientCommandKeyValues( ::edict_t * pEntity, ::KeyValues * pKeyValues ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientCommandKeyValues: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientCommandKeyValues = this->get_override( "ClientCommandKeyValues" );
        if( func_ClientCommandKeyValues.ptr() != Py_None )
            try {
                func_ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) );
            }
        else
            this->CMultiplayRules::ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) );
    }
    
    void default_ClientCommandKeyValues( ::edict_t * pEntity, ::KeyValues * pKeyValues ) {
        CMultiplayRules::ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) );
    }

    virtual bool ClientConnected( ::edict_t * pEntity, char const * pszName, char const * pszAddress, char * reject, int maxrejectlen ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientConnected: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ClientConnected( boost::python::ptr(pEntity), pszName, pszAddress, reject, maxrejectlen ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientConnected = this->get_override( "ClientConnected" );
        if( func_ClientConnected.ptr() != Py_None )
            try {
                return func_ClientConnected( boost::python::ptr(pEntity), pszName, pszAddress, reject, maxrejectlen );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::ClientConnected( boost::python::ptr(pEntity), pszName, pszAddress, reject, maxrejectlen );
            }
        else
            return this->CMultiplayRules::ClientConnected( boost::python::ptr(pEntity), pszName, pszAddress, reject, maxrejectlen );
    }
    
    bool default_ClientConnected( ::edict_t * pEntity, char const * pszName, char const * pszAddress, char * reject, int maxrejectlen ) {
        return CMultiplayRules::ClientConnected( boost::python::ptr(pEntity), pszName, pszAddress, reject, maxrejectlen );
    }

    virtual void ClientDisconnected( ::edict_t * pClient ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientDisconnected: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ClientDisconnected( boost::python::ptr(pClient) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientDisconnected = this->get_override( "ClientDisconnected" );
        if( func_ClientDisconnected.ptr() != Py_None )
            try {
                func_ClientDisconnected( boost::python::ptr(pClient) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::ClientDisconnected( boost::python::ptr(pClient) );
            }
        else
            this->CMultiplayRules::ClientDisconnected( boost::python::ptr(pClient) );
    }
    
    void default_ClientDisconnected( ::edict_t * pClient ) {
        CMultiplayRules::ClientDisconnected( boost::python::ptr(pClient) );
    }

    virtual void ClientSettingsChanged( ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientSettingsChanged: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ClientSettingsChanged( boost::python::ptr(pPlayer) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientSettingsChanged = this->get_override( "ClientSettingsChanged" );
        if( func_ClientSettingsChanged.ptr() != Py_None )
            try {
                func_ClientSettingsChanged( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::ClientSettingsChanged( boost::python::ptr(pPlayer) );
            }
        else
            this->CMultiplayRules::ClientSettingsChanged( boost::python::ptr(pPlayer) );
    }
    
    void default_ClientSettingsChanged( ::CBasePlayer * pPlayer ) {
        CMultiplayRules::ClientSettingsChanged( boost::python::ptr(pPlayer) );
    }

    virtual int Damage_GetNoPhysicsForce(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetNoPhysicsForce: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetNoPhysicsForce(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetNoPhysicsForce = this->get_override( "Damage_GetNoPhysicsForce" );
        if( func_Damage_GetNoPhysicsForce.ptr() != Py_None )
            try {
                return func_Damage_GetNoPhysicsForce(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::Damage_GetNoPhysicsForce(  );
            }
        else
            return this->CMultiplayRules::Damage_GetNoPhysicsForce(  );
    }
    
    int default_Damage_GetNoPhysicsForce(  ) {
        return CMultiplayRules::Damage_GetNoPhysicsForce( );
    }

    virtual int Damage_GetShouldGibCorpse(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetShouldGibCorpse: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetShouldGibCorpse(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetShouldGibCorpse = this->get_override( "Damage_GetShouldGibCorpse" );
        if( func_Damage_GetShouldGibCorpse.ptr() != Py_None )
            try {
                return func_Damage_GetShouldGibCorpse(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::Damage_GetShouldGibCorpse(  );
            }
        else
            return this->CMultiplayRules::Damage_GetShouldGibCorpse(  );
    }
    
    int default_Damage_GetShouldGibCorpse(  ) {
        return CMultiplayRules::Damage_GetShouldGibCorpse( );
    }

    virtual int Damage_GetShouldNotBleed(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetShouldNotBleed: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetShouldNotBleed(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetShouldNotBleed = this->get_override( "Damage_GetShouldNotBleed" );
        if( func_Damage_GetShouldNotBleed.ptr() != Py_None )
            try {
                return func_Damage_GetShouldNotBleed(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::Damage_GetShouldNotBleed(  );
            }
        else
            return this->CMultiplayRules::Damage_GetShouldNotBleed(  );
    }
    
    int default_Damage_GetShouldNotBleed(  ) {
        return CMultiplayRules::Damage_GetShouldNotBleed( );
    }

    virtual int Damage_GetShowOnHud(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetShowOnHud: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetShowOnHud(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetShowOnHud = this->get_override( "Damage_GetShowOnHud" );
        if( func_Damage_GetShowOnHud.ptr() != Py_None )
            try {
                return func_Damage_GetShowOnHud(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::Damage_GetShowOnHud(  );
            }
        else
            return this->CMultiplayRules::Damage_GetShowOnHud(  );
    }
    
    int default_Damage_GetShowOnHud(  ) {
        return CMultiplayRules::Damage_GetShowOnHud( );
    }

    virtual int Damage_GetTimeBased(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetTimeBased: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetTimeBased(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetTimeBased = this->get_override( "Damage_GetTimeBased" );
        if( func_Damage_GetTimeBased.ptr() != Py_None )
            try {
                return func_Damage_GetTimeBased(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::Damage_GetTimeBased(  );
            }
        else
            return this->CMultiplayRules::Damage_GetTimeBased(  );
    }
    
    int default_Damage_GetTimeBased(  ) {
        return CMultiplayRules::Damage_GetTimeBased( );
    }

    virtual bool Damage_IsTimeBased( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_IsTimeBased: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_IsTimeBased( iDmgType ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_IsTimeBased = this->get_override( "Damage_IsTimeBased" );
        if( func_Damage_IsTimeBased.ptr() != Py_None )
            try {
                return func_Damage_IsTimeBased( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::Damage_IsTimeBased( iDmgType );
            }
        else
            return this->CMultiplayRules::Damage_IsTimeBased( iDmgType );
    }
    
    bool default_Damage_IsTimeBased( int iDmgType ) {
        return CMultiplayRules::Damage_IsTimeBased( iDmgType );
    }

    virtual bool Damage_NoPhysicsForce( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_NoPhysicsForce: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_NoPhysicsForce( iDmgType ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_NoPhysicsForce = this->get_override( "Damage_NoPhysicsForce" );
        if( func_Damage_NoPhysicsForce.ptr() != Py_None )
            try {
                return func_Damage_NoPhysicsForce( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::Damage_NoPhysicsForce( iDmgType );
            }
        else
            return this->CMultiplayRules::Damage_NoPhysicsForce( iDmgType );
    }
    
    bool default_Damage_NoPhysicsForce( int iDmgType ) {
        return CMultiplayRules::Damage_NoPhysicsForce( iDmgType );
    }

    virtual bool Damage_ShouldGibCorpse( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_ShouldGibCorpse: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_ShouldGibCorpse( iDmgType ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_ShouldGibCorpse = this->get_override( "Damage_ShouldGibCorpse" );
        if( func_Damage_ShouldGibCorpse.ptr() != Py_None )
            try {
                return func_Damage_ShouldGibCorpse( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::Damage_ShouldGibCorpse( iDmgType );
            }
        else
            return this->CMultiplayRules::Damage_ShouldGibCorpse( iDmgType );
    }
    
    bool default_Damage_ShouldGibCorpse( int iDmgType ) {
        return CMultiplayRules::Damage_ShouldGibCorpse( iDmgType );
    }

    virtual bool Damage_ShouldNotBleed( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_ShouldNotBleed: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_ShouldNotBleed( iDmgType ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_ShouldNotBleed = this->get_override( "Damage_ShouldNotBleed" );
        if( func_Damage_ShouldNotBleed.ptr() != Py_None )
            try {
                return func_Damage_ShouldNotBleed( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::Damage_ShouldNotBleed( iDmgType );
            }
        else
            return this->CMultiplayRules::Damage_ShouldNotBleed( iDmgType );
    }
    
    bool default_Damage_ShouldNotBleed( int iDmgType ) {
        return CMultiplayRules::Damage_ShouldNotBleed( iDmgType );
    }

    virtual bool Damage_ShowOnHUD( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_ShowOnHUD: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_ShowOnHUD( iDmgType ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_ShowOnHUD = this->get_override( "Damage_ShowOnHUD" );
        if( func_Damage_ShowOnHUD.ptr() != Py_None )
            try {
                return func_Damage_ShowOnHUD( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::Damage_ShowOnHUD( iDmgType );
            }
        else
            return this->CMultiplayRules::Damage_ShowOnHUD( iDmgType );
    }
    
    bool default_Damage_ShowOnHUD( int iDmgType ) {
        return CMultiplayRules::Damage_ShowOnHUD( iDmgType );
    }

    virtual int DeadPlayerAmmo( ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "DeadPlayerAmmo: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling DeadPlayerAmmo( boost::python::ptr(pPlayer) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_DeadPlayerAmmo = this->get_override( "DeadPlayerAmmo" );
        if( func_DeadPlayerAmmo.ptr() != Py_None )
            try {
                return func_DeadPlayerAmmo( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::DeadPlayerAmmo( boost::python::ptr(pPlayer) );
            }
        else
            return this->CMultiplayRules::DeadPlayerAmmo( boost::python::ptr(pPlayer) );
    }
    
    int default_DeadPlayerAmmo( ::CBasePlayer * pPlayer ) {
        return CMultiplayRules::DeadPlayerAmmo( boost::python::ptr(pPlayer) );
    }

    virtual int DeadPlayerWeapons( ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "DeadPlayerWeapons: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling DeadPlayerWeapons( boost::python::ptr(pPlayer) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_DeadPlayerWeapons = this->get_override( "DeadPlayerWeapons" );
        if( func_DeadPlayerWeapons.ptr() != Py_None )
            try {
                return func_DeadPlayerWeapons( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::DeadPlayerWeapons( boost::python::ptr(pPlayer) );
            }
        else
            return this->CMultiplayRules::DeadPlayerWeapons( boost::python::ptr(pPlayer) );
    }
    
    int default_DeadPlayerWeapons( ::CBasePlayer * pPlayer ) {
        return CMultiplayRules::DeadPlayerWeapons( boost::python::ptr(pPlayer) );
    }

    virtual void DeathNotice( ::CBasePlayer * pVictim, ::CTakeDamageInfo const & info ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "DeathNotice: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling DeathNotice( boost::python::ptr(pVictim), boost::ref(info) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_DeathNotice = this->get_override( "DeathNotice" );
        if( func_DeathNotice.ptr() != Py_None )
            try {
                func_DeathNotice( boost::python::ptr(pVictim), boost::ref(info) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::DeathNotice( boost::python::ptr(pVictim), boost::ref(info) );
            }
        else
            this->CMultiplayRules::DeathNotice( boost::python::ptr(pVictim), boost::ref(info) );
    }
    
    void default_DeathNotice( ::CBasePlayer * pVictim, ::CTakeDamageInfo const & info ) {
        CMultiplayRules::DeathNotice( boost::python::ptr(pVictim), boost::ref(info) );
    }

    virtual void EndMultiplayerGame(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "EndMultiplayerGame: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling EndMultiplayerGame(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_EndMultiplayerGame = this->get_override( "EndMultiplayerGame" );
        if( func_EndMultiplayerGame.ptr() != Py_None )
            try {
                func_EndMultiplayerGame(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::EndMultiplayerGame(  );
            }
        else
            this->CMultiplayRules::EndMultiplayerGame(  );
    }
    
    void default_EndMultiplayerGame(  ) {
        CMultiplayRules::EndMultiplayerGame( );
    }

    virtual bool FAllowFlashlight(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FAllowFlashlight: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FAllowFlashlight(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FAllowFlashlight = this->get_override( "FAllowFlashlight" );
        if( func_FAllowFlashlight.ptr() != Py_None )
            try {
                return func_FAllowFlashlight(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::FAllowFlashlight(  );
            }
        else
            return this->CMultiplayRules::FAllowFlashlight(  );
    }
    
    bool default_FAllowFlashlight(  ) {
        return CMultiplayRules::FAllowFlashlight( );
    }

    virtual bool FAllowNPCs(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FAllowNPCs: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FAllowNPCs(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FAllowNPCs = this->get_override( "FAllowNPCs" );
        if( func_FAllowNPCs.ptr() != Py_None )
            try {
                return func_FAllowNPCs(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::FAllowNPCs(  );
            }
        else
            return this->CMultiplayRules::FAllowNPCs(  );
    }
    
    bool default_FAllowNPCs(  ) {
        return CMultiplayRules::FAllowNPCs( );
    }

    virtual bool FPlayerCanRespawn( ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FPlayerCanRespawn: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FPlayerCanRespawn( boost::python::ptr(pPlayer) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FPlayerCanRespawn = this->get_override( "FPlayerCanRespawn" );
        if( func_FPlayerCanRespawn.ptr() != Py_None )
            try {
                return func_FPlayerCanRespawn( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::FPlayerCanRespawn( boost::python::ptr(pPlayer) );
            }
        else
            return this->CMultiplayRules::FPlayerCanRespawn( boost::python::ptr(pPlayer) );
    }
    
    bool default_FPlayerCanRespawn( ::CBasePlayer * pPlayer ) {
        return CMultiplayRules::FPlayerCanRespawn( boost::python::ptr(pPlayer) );
    }

    virtual bool FPlayerCanTakeDamage( ::CBasePlayer * pPlayer, ::CBaseEntity * pAttacker ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FPlayerCanTakeDamage: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FPlayerCanTakeDamage( boost::python::ptr(pPlayer), boost::python::ptr(pAttacker) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FPlayerCanTakeDamage = this->get_override( "FPlayerCanTakeDamage" );
        if( func_FPlayerCanTakeDamage.ptr() != Py_None )
            try {
                return func_FPlayerCanTakeDamage( boost::python::ptr(pPlayer), boost::python::ptr(pAttacker) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::FPlayerCanTakeDamage( boost::python::ptr(pPlayer), boost::python::ptr(pAttacker) );
            }
        else
            return this->CMultiplayRules::FPlayerCanTakeDamage( boost::python::ptr(pPlayer), boost::python::ptr(pAttacker) );
    }
    
    bool default_FPlayerCanTakeDamage( ::CBasePlayer * pPlayer, ::CBaseEntity * pAttacker ) {
        return CMultiplayRules::FPlayerCanTakeDamage( boost::python::ptr(pPlayer), boost::python::ptr(pAttacker) );
    }

    virtual bool FShouldSwitchWeapon( ::CBasePlayer * pPlayer, ::CBaseCombatWeapon * pWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FShouldSwitchWeapon: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FShouldSwitchWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pWeapon) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FShouldSwitchWeapon = this->get_override( "FShouldSwitchWeapon" );
        if( func_FShouldSwitchWeapon.ptr() != Py_None )
            try {
                return func_FShouldSwitchWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::FShouldSwitchWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pWeapon) );
            }
        else
            return this->CMultiplayRules::FShouldSwitchWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pWeapon) );
    }
    
    bool default_FShouldSwitchWeapon( ::CBasePlayer * pPlayer, ::CBaseCombatWeapon * pWeapon ) {
        return CMultiplayRules::FShouldSwitchWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pWeapon) );
    }

    virtual float FlHEVChargerRechargeTime(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FlHEVChargerRechargeTime: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FlHEVChargerRechargeTime(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FlHEVChargerRechargeTime = this->get_override( "FlHEVChargerRechargeTime" );
        if( func_FlHEVChargerRechargeTime.ptr() != Py_None )
            try {
                return func_FlHEVChargerRechargeTime(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::FlHEVChargerRechargeTime(  );
            }
        else
            return this->CMultiplayRules::FlHEVChargerRechargeTime(  );
    }
    
    float default_FlHEVChargerRechargeTime(  ) {
        return CMultiplayRules::FlHEVChargerRechargeTime( );
    }

    virtual float FlHealthChargerRechargeTime(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FlHealthChargerRechargeTime: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FlHealthChargerRechargeTime(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FlHealthChargerRechargeTime = this->get_override( "FlHealthChargerRechargeTime" );
        if( func_FlHealthChargerRechargeTime.ptr() != Py_None )
            try {
                return func_FlHealthChargerRechargeTime(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::FlHealthChargerRechargeTime(  );
            }
        else
            return this->CMultiplayRules::FlHealthChargerRechargeTime(  );
    }
    
    float default_FlHealthChargerRechargeTime(  ) {
        return CMultiplayRules::FlHealthChargerRechargeTime( );
    }

    virtual float FlItemRespawnTime( ::CItem * pItem ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FlItemRespawnTime: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FlItemRespawnTime( boost::python::ptr(pItem) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FlItemRespawnTime = this->get_override( "FlItemRespawnTime" );
        if( func_FlItemRespawnTime.ptr() != Py_None )
            try {
                return func_FlItemRespawnTime( boost::python::ptr(pItem) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::FlItemRespawnTime( boost::python::ptr(pItem) );
            }
        else
            return this->CMultiplayRules::FlItemRespawnTime( boost::python::ptr(pItem) );
    }
    
    float default_FlItemRespawnTime( ::CItem * pItem ) {
        return CMultiplayRules::FlItemRespawnTime( boost::python::ptr(pItem) );
    }

    virtual float FlPlayerFallDamage( ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FlPlayerFallDamage: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FlPlayerFallDamage( boost::python::ptr(pPlayer) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FlPlayerFallDamage = this->get_override( "FlPlayerFallDamage" );
        if( func_FlPlayerFallDamage.ptr() != Py_None )
            try {
                return func_FlPlayerFallDamage( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::FlPlayerFallDamage( boost::python::ptr(pPlayer) );
            }
        else
            return this->CMultiplayRules::FlPlayerFallDamage( boost::python::ptr(pPlayer) );
    }
    
    float default_FlPlayerFallDamage( ::CBasePlayer * pPlayer ) {
        return CMultiplayRules::FlPlayerFallDamage( boost::python::ptr(pPlayer) );
    }

    virtual float FlPlayerSpawnTime( ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FlPlayerSpawnTime: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FlPlayerSpawnTime( boost::python::ptr(pPlayer) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FlPlayerSpawnTime = this->get_override( "FlPlayerSpawnTime" );
        if( func_FlPlayerSpawnTime.ptr() != Py_None )
            try {
                return func_FlPlayerSpawnTime( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::FlPlayerSpawnTime( boost::python::ptr(pPlayer) );
            }
        else
            return this->CMultiplayRules::FlPlayerSpawnTime( boost::python::ptr(pPlayer) );
    }
    
    float default_FlPlayerSpawnTime( ::CBasePlayer * pPlayer ) {
        return CMultiplayRules::FlPlayerSpawnTime( boost::python::ptr(pPlayer) );
    }

    virtual float FlWeaponRespawnTime( ::CBaseCombatWeapon * pWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FlWeaponRespawnTime: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FlWeaponRespawnTime( boost::python::ptr(pWeapon) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FlWeaponRespawnTime = this->get_override( "FlWeaponRespawnTime" );
        if( func_FlWeaponRespawnTime.ptr() != Py_None )
            try {
                return func_FlWeaponRespawnTime( boost::python::ptr(pWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::FlWeaponRespawnTime( boost::python::ptr(pWeapon) );
            }
        else
            return this->CMultiplayRules::FlWeaponRespawnTime( boost::python::ptr(pWeapon) );
    }
    
    float default_FlWeaponRespawnTime( ::CBaseCombatWeapon * pWeapon ) {
        return CMultiplayRules::FlWeaponRespawnTime( boost::python::ptr(pWeapon) );
    }

    virtual float FlWeaponTryRespawn( ::CBaseCombatWeapon * pWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FlWeaponTryRespawn: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FlWeaponTryRespawn( boost::python::ptr(pWeapon) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FlWeaponTryRespawn = this->get_override( "FlWeaponTryRespawn" );
        if( func_FlWeaponTryRespawn.ptr() != Py_None )
            try {
                return func_FlWeaponTryRespawn( boost::python::ptr(pWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::FlWeaponTryRespawn( boost::python::ptr(pWeapon) );
            }
        else
            return this->CMultiplayRules::FlWeaponTryRespawn( boost::python::ptr(pWeapon) );
    }
    
    float default_FlWeaponTryRespawn( ::CBaseCombatWeapon * pWeapon ) {
        return CMultiplayRules::FlWeaponTryRespawn( boost::python::ptr(pWeapon) );
    }

    virtual void FrameUpdatePostEntityThink(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FrameUpdatePostEntityThink: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FrameUpdatePostEntityThink(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FrameUpdatePostEntityThink = this->get_override( "FrameUpdatePostEntityThink" );
        if( func_FrameUpdatePostEntityThink.ptr() != Py_None )
            try {
                func_FrameUpdatePostEntityThink(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::FrameUpdatePostEntityThink(  );
            }
        else
            this->CMultiplayRules::FrameUpdatePostEntityThink(  );
    }
    
    void default_FrameUpdatePostEntityThink(  ) {
        CMultiplayRules::FrameUpdatePostEntityThink( );
    }

    virtual ::CBasePlayer * GetDeathScorer( ::CBaseEntity * pKiller, ::CBaseEntity * pInflictor, ::CBaseEntity * pVictim ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetDeathScorer: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetDeathScorer( boost::python::ptr(pKiller), boost::python::ptr(pInflictor), boost::python::ptr(pVictim) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetDeathScorer = this->get_override( "GetDeathScorer" );
        if( func_GetDeathScorer.ptr() != Py_None )
            try {
                return func_GetDeathScorer( boost::python::ptr(pKiller), boost::python::ptr(pInflictor), boost::python::ptr(pVictim) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::GetDeathScorer( boost::python::ptr(pKiller), boost::python::ptr(pInflictor), boost::python::ptr(pVictim) );
            }
        else
            return this->CMultiplayRules::GetDeathScorer( boost::python::ptr(pKiller), boost::python::ptr(pInflictor), boost::python::ptr(pVictim) );
    }
    
    ::CBasePlayer * default_GetDeathScorer( ::CBaseEntity * pKiller, ::CBaseEntity * pInflictor, ::CBaseEntity * pVictim ) {
        return CMultiplayRules::GetDeathScorer( boost::python::ptr(pKiller), boost::python::ptr(pInflictor), boost::python::ptr(pVictim) );
    }

    virtual ::CBaseCombatWeapon * GetNextBestWeapon( ::CBaseCombatCharacter * pPlayer, ::CBaseCombatWeapon * pCurrentWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetNextBestWeapon: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetNextBestWeapon = this->get_override( "GetNextBestWeapon" );
        if( func_GetNextBestWeapon.ptr() != Py_None )
            try {
                return func_GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
            }
        else
            return this->CMultiplayRules::GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
    }
    
    ::CBaseCombatWeapon * default_GetNextBestWeapon( ::CBaseCombatCharacter * pPlayer, ::CBaseCombatWeapon * pCurrentWeapon ) {
        return CMultiplayRules::GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
    }

    virtual void GetNextLevelName( char * szNextMap, int bufsize, bool bRandom=false ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetNextLevelName: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetNextLevelName( szNextMap, bufsize, bRandom ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetNextLevelName = this->get_override( "GetNextLevelName" );
        if( func_GetNextLevelName.ptr() != Py_None )
            try {
                func_GetNextLevelName( szNextMap, bufsize, bRandom );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::GetNextLevelName( szNextMap, bufsize, bRandom );
            }
        else
            this->CMultiplayRules::GetNextLevelName( szNextMap, bufsize, bRandom );
    }
    
    void default_GetNextLevelName( char * szNextMap, int bufsize, bool bRandom=false ) {
        CMultiplayRules::GetNextLevelName( szNextMap, bufsize, bRandom );
    }

    virtual ::CBaseEntity * GetPlayerSpawnSpot( ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetPlayerSpawnSpot: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetPlayerSpawnSpot( boost::python::ptr(pPlayer) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetPlayerSpawnSpot = this->get_override( "GetPlayerSpawnSpot" );
        if( func_GetPlayerSpawnSpot.ptr() != Py_None )
            try {
                return func_GetPlayerSpawnSpot( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::GetPlayerSpawnSpot( boost::python::ptr(pPlayer) );
            }
        else
            return this->CMultiplayRules::GetPlayerSpawnSpot( boost::python::ptr(pPlayer) );
    }
    
    ::CBaseEntity * default_GetPlayerSpawnSpot( ::CBasePlayer * pPlayer ) {
        return CMultiplayRules::GetPlayerSpawnSpot( boost::python::ptr(pPlayer) );
    }

    virtual void GetTaggedConVarList( ::KeyValues * pCvarTagList ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetTaggedConVarList: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetTaggedConVarList( boost::python::ptr(pCvarTagList) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetTaggedConVarList = this->get_override( "GetTaggedConVarList" );
        if( func_GetTaggedConVarList.ptr() != Py_None )
            try {
                func_GetTaggedConVarList( boost::python::ptr(pCvarTagList) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::GetTaggedConVarList( boost::python::ptr(pCvarTagList) );
            }
        else
            this->CMultiplayRules::GetTaggedConVarList( boost::python::ptr(pCvarTagList) );
    }
    
    void default_GetTaggedConVarList( ::KeyValues * pCvarTagList ) {
        CMultiplayRules::GetTaggedConVarList( boost::python::ptr(pCvarTagList) );
    }

    virtual char const * GetTeamID( ::CBaseEntity * pEntity ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetTeamID: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetTeamID( boost::python::ptr(pEntity) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetTeamID = this->get_override( "GetTeamID" );
        if( func_GetTeamID.ptr() != Py_None )
            try {
                return func_GetTeamID( boost::python::ptr(pEntity) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::GetTeamID( boost::python::ptr(pEntity) );
            }
        else
            return this->CMultiplayRules::GetTeamID( boost::python::ptr(pEntity) );
    }
    
    char const * default_GetTeamID( ::CBaseEntity * pEntity ) {
        return CMultiplayRules::GetTeamID( boost::python::ptr(pEntity) );
    }

    virtual void HandleTimeLimitChange(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "HandleTimeLimitChange: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling HandleTimeLimitChange(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_HandleTimeLimitChange = this->get_override( "HandleTimeLimitChange" );
        if( func_HandleTimeLimitChange.ptr() != Py_None )
            try {
                func_HandleTimeLimitChange(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::HandleTimeLimitChange(  );
            }
        else
            this->CMultiplayRules::HandleTimeLimitChange(  );
    }
    
    void default_HandleTimeLimitChange(  ) {
        CMultiplayRules::HandleTimeLimitChange( );
    }

    virtual int IPointsForKill( ::CBasePlayer * pAttacker, ::CBasePlayer * pKilled ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IPointsForKill: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IPointsForKill( boost::python::ptr(pAttacker), boost::python::ptr(pKilled) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IPointsForKill = this->get_override( "IPointsForKill" );
        if( func_IPointsForKill.ptr() != Py_None )
            try {
                return func_IPointsForKill( boost::python::ptr(pAttacker), boost::python::ptr(pKilled) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::IPointsForKill( boost::python::ptr(pAttacker), boost::python::ptr(pKilled) );
            }
        else
            return this->CMultiplayRules::IPointsForKill( boost::python::ptr(pAttacker), boost::python::ptr(pKilled) );
    }
    
    int default_IPointsForKill( ::CBasePlayer * pAttacker, ::CBasePlayer * pKilled ) {
        return CMultiplayRules::IPointsForKill( boost::python::ptr(pAttacker), boost::python::ptr(pKilled) );
    }

    virtual bool Init(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Init: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Init(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Init = this->get_override( "Init" );
        if( func_Init.ptr() != Py_None )
            try {
                return func_Init(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::Init(  );
            }
        else
            return this->CMultiplayRules::Init(  );
    }
    
    bool default_Init(  ) {
        return CMultiplayRules::Init( );
    }

    virtual void InitCustomResponseRulesDicts(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "InitCustomResponseRulesDicts: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling InitCustomResponseRulesDicts(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_InitCustomResponseRulesDicts = this->get_override( "InitCustomResponseRulesDicts" );
        if( func_InitCustomResponseRulesDicts.ptr() != Py_None )
            try {
                func_InitCustomResponseRulesDicts(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::InitCustomResponseRulesDicts(  );
            }
        else
            this->CMultiplayRules::InitCustomResponseRulesDicts(  );
    }
    
    void default_InitCustomResponseRulesDicts(  ) {
        CMultiplayRules::InitCustomResponseRulesDicts( );
    }

    virtual void InitHUD( ::CBasePlayer * pl ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "InitHUD: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling InitHUD( boost::python::ptr(pl) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_InitHUD = this->get_override( "InitHUD" );
        if( func_InitHUD.ptr() != Py_None )
            try {
                func_InitHUD( boost::python::ptr(pl) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::InitHUD( boost::python::ptr(pl) );
            }
        else
            this->CMultiplayRules::InitHUD( boost::python::ptr(pl) );
    }
    
    void default_InitHUD( ::CBasePlayer * pl ) {
        CMultiplayRules::InitHUD( boost::python::ptr(pl) );
    }

    virtual bool IsAllowedToSpawn( ::CBaseEntity * pEntity ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsAllowedToSpawn: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsAllowedToSpawn( boost::python::ptr(pEntity) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsAllowedToSpawn = this->get_override( "IsAllowedToSpawn" );
        if( func_IsAllowedToSpawn.ptr() != Py_None )
            try {
                return func_IsAllowedToSpawn( boost::python::ptr(pEntity) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::IsAllowedToSpawn( boost::python::ptr(pEntity) );
            }
        else
            return this->CMultiplayRules::IsAllowedToSpawn( boost::python::ptr(pEntity) );
    }
    
    bool default_IsAllowedToSpawn( ::CBaseEntity * pEntity ) {
        return CMultiplayRules::IsAllowedToSpawn( boost::python::ptr(pEntity) );
    }

    virtual bool IsCoOp(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsCoOp: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsCoOp(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsCoOp = this->get_override( "IsCoOp" );
        if( func_IsCoOp.ptr() != Py_None )
            try {
                return func_IsCoOp(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::IsCoOp(  );
            }
        else
            return this->CMultiplayRules::IsCoOp(  );
    }
    
    bool default_IsCoOp(  ) {
        return CMultiplayRules::IsCoOp( );
    }

    virtual bool IsDeathmatch(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsDeathmatch: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsDeathmatch(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsDeathmatch = this->get_override( "IsDeathmatch" );
        if( func_IsDeathmatch.ptr() != Py_None )
            try {
                return func_IsDeathmatch(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::IsDeathmatch(  );
            }
        else
            return this->CMultiplayRules::IsDeathmatch(  );
    }
    
    bool default_IsDeathmatch(  ) {
        return CMultiplayRules::IsDeathmatch( );
    }

    virtual bool IsMultiplayer(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsMultiplayer: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsMultiplayer(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsMultiplayer = this->get_override( "IsMultiplayer" );
        if( func_IsMultiplayer.ptr() != Py_None )
            try {
                return func_IsMultiplayer(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::IsMultiplayer(  );
            }
        else
            return this->CMultiplayRules::IsMultiplayer(  );
    }
    
    bool default_IsMultiplayer(  ) {
        return CMultiplayRules::IsMultiplayer( );
    }

    virtual int ItemShouldRespawn( ::CItem * pItem ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ItemShouldRespawn: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ItemShouldRespawn( boost::python::ptr(pItem) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ItemShouldRespawn = this->get_override( "ItemShouldRespawn" );
        if( func_ItemShouldRespawn.ptr() != Py_None )
            try {
                return func_ItemShouldRespawn( boost::python::ptr(pItem) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::ItemShouldRespawn( boost::python::ptr(pItem) );
            }
        else
            return this->CMultiplayRules::ItemShouldRespawn( boost::python::ptr(pItem) );
    }
    
    int default_ItemShouldRespawn( ::CItem * pItem ) {
        return CMultiplayRules::ItemShouldRespawn( boost::python::ptr(pItem) );
    }

    virtual bool PlayFootstepSounds( ::CBasePlayer * pl ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PlayFootstepSounds: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PlayFootstepSounds( boost::python::ptr(pl) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PlayFootstepSounds = this->get_override( "PlayFootstepSounds" );
        if( func_PlayFootstepSounds.ptr() != Py_None )
            try {
                return func_PlayFootstepSounds( boost::python::ptr(pl) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::PlayFootstepSounds( boost::python::ptr(pl) );
            }
        else
            return this->CMultiplayRules::PlayFootstepSounds( boost::python::ptr(pl) );
    }
    
    bool default_PlayFootstepSounds( ::CBasePlayer * pl ) {
        return CMultiplayRules::PlayFootstepSounds( boost::python::ptr(pl) );
    }

    virtual bool PlayTextureSounds(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PlayTextureSounds: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PlayTextureSounds(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PlayTextureSounds = this->get_override( "PlayTextureSounds" );
        if( func_PlayTextureSounds.ptr() != Py_None )
            try {
                return func_PlayTextureSounds(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::PlayTextureSounds(  );
            }
        else
            return this->CMultiplayRules::PlayTextureSounds(  );
    }
    
    bool default_PlayTextureSounds(  ) {
        return CMultiplayRules::PlayTextureSounds( );
    }

    virtual bool PlayerCanHearChat( ::CBasePlayer * pListener, ::CBasePlayer * pSpeaker ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PlayerCanHearChat: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PlayerCanHearChat( boost::python::ptr(pListener), boost::python::ptr(pSpeaker) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PlayerCanHearChat = this->get_override( "PlayerCanHearChat" );
        if( func_PlayerCanHearChat.ptr() != Py_None )
            try {
                return func_PlayerCanHearChat( boost::python::ptr(pListener), boost::python::ptr(pSpeaker) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::PlayerCanHearChat( boost::python::ptr(pListener), boost::python::ptr(pSpeaker) );
            }
        else
            return this->CMultiplayRules::PlayerCanHearChat( boost::python::ptr(pListener), boost::python::ptr(pSpeaker) );
    }
    
    bool default_PlayerCanHearChat( ::CBasePlayer * pListener, ::CBasePlayer * pSpeaker ) {
        return CMultiplayRules::PlayerCanHearChat( boost::python::ptr(pListener), boost::python::ptr(pSpeaker) );
    }

    virtual void PlayerGotAmmo( ::CBaseCombatCharacter * pPlayer, char * szName, int iCount ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PlayerGotAmmo: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PlayerGotAmmo( boost::python::ptr(pPlayer), szName, iCount ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PlayerGotAmmo = this->get_override( "PlayerGotAmmo" );
        if( func_PlayerGotAmmo.ptr() != Py_None )
            try {
                func_PlayerGotAmmo( boost::python::ptr(pPlayer), szName, iCount );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::PlayerGotAmmo( boost::python::ptr(pPlayer), szName, iCount );
            }
        else
            this->CMultiplayRules::PlayerGotAmmo( boost::python::ptr(pPlayer), szName, iCount );
    }
    
    void default_PlayerGotAmmo( ::CBaseCombatCharacter * pPlayer, char * szName, int iCount ) {
        CMultiplayRules::PlayerGotAmmo( boost::python::ptr(pPlayer), szName, iCount );
    }

    virtual void PlayerGotItem( ::CBasePlayer * pPlayer, ::CItem * pItem ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PlayerGotItem: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PlayerGotItem( boost::python::ptr(pPlayer), boost::python::ptr(pItem) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PlayerGotItem = this->get_override( "PlayerGotItem" );
        if( func_PlayerGotItem.ptr() != Py_None )
            try {
                func_PlayerGotItem( boost::python::ptr(pPlayer), boost::python::ptr(pItem) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::PlayerGotItem( boost::python::ptr(pPlayer), boost::python::ptr(pItem) );
            }
        else
            this->CMultiplayRules::PlayerGotItem( boost::python::ptr(pPlayer), boost::python::ptr(pItem) );
    }
    
    void default_PlayerGotItem( ::CBasePlayer * pPlayer, ::CItem * pItem ) {
        CMultiplayRules::PlayerGotItem( boost::python::ptr(pPlayer), boost::python::ptr(pItem) );
    }

    virtual void PlayerKilled( ::CBasePlayer * pVictim, ::CTakeDamageInfo const & info ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PlayerKilled: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PlayerKilled( boost::python::ptr(pVictim), boost::ref(info) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PlayerKilled = this->get_override( "PlayerKilled" );
        if( func_PlayerKilled.ptr() != Py_None )
            try {
                func_PlayerKilled( boost::python::ptr(pVictim), boost::ref(info) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::PlayerKilled( boost::python::ptr(pVictim), boost::ref(info) );
            }
        else
            this->CMultiplayRules::PlayerKilled( boost::python::ptr(pVictim), boost::ref(info) );
    }
    
    void default_PlayerKilled( ::CBasePlayer * pVictim, ::CTakeDamageInfo const & info ) {
        CMultiplayRules::PlayerKilled( boost::python::ptr(pVictim), boost::ref(info) );
    }

    virtual int PlayerRelationship( ::CBaseEntity * pPlayer, ::CBaseEntity * pTarget ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PlayerRelationship: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PlayerRelationship( boost::python::ptr(pPlayer), boost::python::ptr(pTarget) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PlayerRelationship = this->get_override( "PlayerRelationship" );
        if( func_PlayerRelationship.ptr() != Py_None )
            try {
                return func_PlayerRelationship( boost::python::ptr(pPlayer), boost::python::ptr(pTarget) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::PlayerRelationship( boost::python::ptr(pPlayer), boost::python::ptr(pTarget) );
            }
        else
            return this->CMultiplayRules::PlayerRelationship( boost::python::ptr(pPlayer), boost::python::ptr(pTarget) );
    }
    
    int default_PlayerRelationship( ::CBaseEntity * pPlayer, ::CBaseEntity * pTarget ) {
        return CMultiplayRules::PlayerRelationship( boost::python::ptr(pPlayer), boost::python::ptr(pTarget) );
    }

    virtual void PlayerSpawn( ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PlayerSpawn: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PlayerSpawn( boost::python::ptr(pPlayer) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PlayerSpawn = this->get_override( "PlayerSpawn" );
        if( func_PlayerSpawn.ptr() != Py_None )
            try {
                func_PlayerSpawn( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::PlayerSpawn( boost::python::ptr(pPlayer) );
            }
        else
            this->CMultiplayRules::PlayerSpawn( boost::python::ptr(pPlayer) );
    }
    
    void default_PlayerSpawn( ::CBasePlayer * pPlayer ) {
        CMultiplayRules::PlayerSpawn( boost::python::ptr(pPlayer) );
    }

    virtual void PlayerThink( ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PlayerThink: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PlayerThink( boost::python::ptr(pPlayer) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PlayerThink = this->get_override( "PlayerThink" );
        if( func_PlayerThink.ptr() != Py_None )
            try {
                func_PlayerThink( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::PlayerThink( boost::python::ptr(pPlayer) );
            }
        else
            this->CMultiplayRules::PlayerThink( boost::python::ptr(pPlayer) );
    }
    
    void default_PlayerThink( ::CBasePlayer * pPlayer ) {
        CMultiplayRules::PlayerThink( boost::python::ptr(pPlayer) );
    }

    virtual void RefreshSkillData( bool forceUpdate ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "RefreshSkillData: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling RefreshSkillData( forceUpdate ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_RefreshSkillData = this->get_override( "RefreshSkillData" );
        if( func_RefreshSkillData.ptr() != Py_None )
            try {
                func_RefreshSkillData( forceUpdate );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::RefreshSkillData( forceUpdate );
            }
        else
            this->CMultiplayRules::RefreshSkillData( forceUpdate );
    }
    
    void default_RefreshSkillData( bool forceUpdate ) {
        CMultiplayRules::RefreshSkillData( forceUpdate );
    }

    virtual void ResetMapCycleTimeStamp(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ResetMapCycleTimeStamp: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ResetMapCycleTimeStamp(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ResetMapCycleTimeStamp = this->get_override( "ResetMapCycleTimeStamp" );
        if( func_ResetMapCycleTimeStamp.ptr() != Py_None )
            try {
                func_ResetMapCycleTimeStamp(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::ResetMapCycleTimeStamp(  );
            }
        else
            this->CMultiplayRules::ResetMapCycleTimeStamp(  );
    }
    
    void default_ResetMapCycleTimeStamp(  ) {
        CMultiplayRules::ResetMapCycleTimeStamp( );
    }

    virtual bool ShouldDrawHeadLabels(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShouldDrawHeadLabels: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShouldDrawHeadLabels(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShouldDrawHeadLabels = this->get_override( "ShouldDrawHeadLabels" );
        if( func_ShouldDrawHeadLabels.ptr() != Py_None )
            try {
                return func_ShouldDrawHeadLabels(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::ShouldDrawHeadLabels(  );
            }
        else
            return this->CMultiplayRules::ShouldDrawHeadLabels(  );
    }
    
    bool default_ShouldDrawHeadLabels(  ) {
        return CMultiplayRules::ShouldDrawHeadLabels( );
    }

    virtual void ShutdownCustomResponseRulesDicts(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShutdownCustomResponseRulesDicts: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShutdownCustomResponseRulesDicts(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShutdownCustomResponseRulesDicts = this->get_override( "ShutdownCustomResponseRulesDicts" );
        if( func_ShutdownCustomResponseRulesDicts.ptr() != Py_None )
            try {
                func_ShutdownCustomResponseRulesDicts(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::ShutdownCustomResponseRulesDicts(  );
            }
        else
            this->CMultiplayRules::ShutdownCustomResponseRulesDicts(  );
    }
    
    void default_ShutdownCustomResponseRulesDicts(  ) {
        CMultiplayRules::ShutdownCustomResponseRulesDicts( );
    }

    virtual bool SwitchToNextBestWeapon( ::CBaseCombatCharacter * pPlayer, ::CBaseCombatWeapon * pCurrentWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SwitchToNextBestWeapon: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SwitchToNextBestWeapon = this->get_override( "SwitchToNextBestWeapon" );
        if( func_SwitchToNextBestWeapon.ptr() != Py_None )
            try {
                return func_SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
            }
        else
            return this->CMultiplayRules::SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
    }
    
    bool default_SwitchToNextBestWeapon( ::CBaseCombatCharacter * pPlayer, ::CBaseCombatWeapon * pCurrentWeapon ) {
        return CMultiplayRules::SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
    }

    virtual void Think(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Think: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Think(  ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Think = this->get_override( "Think" );
        if( func_Think.ptr() != Py_None )
            try {
                func_Think(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CMultiplayRules::Think(  );
            }
        else
            this->CMultiplayRules::Think(  );
    }
    
    void default_Think(  ) {
        CMultiplayRules::Think( );
    }

    virtual ::QAngle VecItemRespawnAngles( ::CItem * pItem ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "VecItemRespawnAngles: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling VecItemRespawnAngles( boost::python::ptr(pItem) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_VecItemRespawnAngles = this->get_override( "VecItemRespawnAngles" );
        if( func_VecItemRespawnAngles.ptr() != Py_None )
            try {
                return func_VecItemRespawnAngles( boost::python::ptr(pItem) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::VecItemRespawnAngles( boost::python::ptr(pItem) );
            }
        else
            return this->CMultiplayRules::VecItemRespawnAngles( boost::python::ptr(pItem) );
    }
    
    ::QAngle default_VecItemRespawnAngles( ::CItem * pItem ) {
        return CMultiplayRules::VecItemRespawnAngles( boost::python::ptr(pItem) );
    }

    virtual ::Vector VecItemRespawnSpot( ::CItem * pItem ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "VecItemRespawnSpot: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling VecItemRespawnSpot( boost::python::ptr(pItem) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_VecItemRespawnSpot = this->get_override( "VecItemRespawnSpot" );
        if( func_VecItemRespawnSpot.ptr() != Py_None )
            try {
                return func_VecItemRespawnSpot( boost::python::ptr(pItem) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::VecItemRespawnSpot( boost::python::ptr(pItem) );
            }
        else
            return this->CMultiplayRules::VecItemRespawnSpot( boost::python::ptr(pItem) );
    }
    
    ::Vector default_VecItemRespawnSpot( ::CItem * pItem ) {
        return CMultiplayRules::VecItemRespawnSpot( boost::python::ptr(pItem) );
    }

    virtual ::Vector VecWeaponRespawnSpot( ::CBaseCombatWeapon * pWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "VecWeaponRespawnSpot: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling VecWeaponRespawnSpot( boost::python::ptr(pWeapon) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_VecWeaponRespawnSpot = this->get_override( "VecWeaponRespawnSpot" );
        if( func_VecWeaponRespawnSpot.ptr() != Py_None )
            try {
                return func_VecWeaponRespawnSpot( boost::python::ptr(pWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::VecWeaponRespawnSpot( boost::python::ptr(pWeapon) );
            }
        else
            return this->CMultiplayRules::VecWeaponRespawnSpot( boost::python::ptr(pWeapon) );
    }
    
    ::Vector default_VecWeaponRespawnSpot( ::CBaseCombatWeapon * pWeapon ) {
        return CMultiplayRules::VecWeaponRespawnSpot( boost::python::ptr(pWeapon) );
    }

    virtual int WeaponShouldRespawn( ::CBaseCombatWeapon * pWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "WeaponShouldRespawn: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling WeaponShouldRespawn( boost::python::ptr(pWeapon) ) of Class: CMultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_WeaponShouldRespawn = this->get_override( "WeaponShouldRespawn" );
        if( func_WeaponShouldRespawn.ptr() != Py_None )
            try {
                return func_WeaponShouldRespawn( boost::python::ptr(pWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CMultiplayRules::WeaponShouldRespawn( boost::python::ptr(pWeapon) );
            }
        else
            return this->CMultiplayRules::WeaponShouldRespawn( boost::python::ptr(pWeapon) );
    }
    
    int default_WeaponShouldRespawn( ::CBaseCombatWeapon * pWeapon ) {
        return CMultiplayRules::WeaponShouldRespawn( boost::python::ptr(pWeapon) );
    }

    virtual char const * AIClassText( int classType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AIClassText: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AIClassText( classType ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AIClassText = this->get_override( "AIClassText" );
        if( func_AIClassText.ptr() != Py_None )
            try {
                return func_AIClassText( classType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::AIClassText( classType );
            }
        else
            return this->CGameRules::AIClassText( classType );
    }
    
    char const * default_AIClassText( int classType ) {
        return CGameRules::AIClassText( classType );
    }

    virtual float AdjustPlayerDamageInflicted( float damage ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AdjustPlayerDamageInflicted: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AdjustPlayerDamageInflicted( damage ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AdjustPlayerDamageInflicted = this->get_override( "AdjustPlayerDamageInflicted" );
        if( func_AdjustPlayerDamageInflicted.ptr() != Py_None )
            try {
                return func_AdjustPlayerDamageInflicted( damage );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::AdjustPlayerDamageInflicted( damage );
            }
        else
            return this->CGameRules::AdjustPlayerDamageInflicted( damage );
    }
    
    float default_AdjustPlayerDamageInflicted( float damage ) {
        return CGameRules::AdjustPlayerDamageInflicted( damage );
    }

    virtual void AdjustPlayerDamageTaken( ::CTakeDamageInfo * pInfo ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AdjustPlayerDamageTaken: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AdjustPlayerDamageTaken( boost::python::ptr(pInfo) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AdjustPlayerDamageTaken = this->get_override( "AdjustPlayerDamageTaken" );
        if( func_AdjustPlayerDamageTaken.ptr() != Py_None )
            try {
                func_AdjustPlayerDamageTaken( boost::python::ptr(pInfo) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::AdjustPlayerDamageTaken( boost::python::ptr(pInfo) );
            }
        else
            this->CGameRules::AdjustPlayerDamageTaken( boost::python::ptr(pInfo) );
    }
    
    void default_AdjustPlayerDamageTaken( ::CTakeDamageInfo * pInfo ) {
        CGameRules::AdjustPlayerDamageTaken( boost::python::ptr(pInfo) );
    }

    virtual bool AllowThirdPersonCamera(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AllowThirdPersonCamera: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AllowThirdPersonCamera(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AllowThirdPersonCamera = this->get_override( "AllowThirdPersonCamera" );
        if( func_AllowThirdPersonCamera.ptr() != Py_None )
            try {
                return func_AllowThirdPersonCamera(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::AllowThirdPersonCamera(  );
            }
        else
            return this->CGameRules::AllowThirdPersonCamera(  );
    }
    
    bool default_AllowThirdPersonCamera(  ) {
        return CGameRules::AllowThirdPersonCamera( );
    }

    virtual bool CanEntityBeUsePushed( ::CBaseEntity * pEnt ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "CanEntityBeUsePushed: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling CanEntityBeUsePushed( boost::python::ptr(pEnt) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_CanEntityBeUsePushed = this->get_override( "CanEntityBeUsePushed" );
        if( func_CanEntityBeUsePushed.ptr() != Py_None )
            try {
                return func_CanEntityBeUsePushed( boost::python::ptr(pEnt) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::CanEntityBeUsePushed( boost::python::ptr(pEnt) );
            }
        else
            return this->CGameRules::CanEntityBeUsePushed( boost::python::ptr(pEnt) );
    }
    
    bool default_CanEntityBeUsePushed( ::CBaseEntity * pEnt ) {
        return CGameRules::CanEntityBeUsePushed( boost::python::ptr(pEnt) );
    }

    virtual bool CanHaveAmmo( ::CBaseCombatCharacter * pPlayer, int iAmmoIndex ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "CanHaveAmmo: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling CanHaveAmmo( boost::python::ptr(pPlayer), iAmmoIndex ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_CanHaveAmmo = this->get_override( "CanHaveAmmo" );
        if( func_CanHaveAmmo.ptr() != Py_None )
            try {
                return func_CanHaveAmmo( boost::python::ptr(pPlayer), iAmmoIndex );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::CanHaveAmmo( boost::python::ptr(pPlayer), iAmmoIndex );
            }
        else
            return this->CGameRules::CanHaveAmmo( boost::python::ptr(pPlayer), iAmmoIndex );
    }
    
    bool default_CanHaveAmmo( ::CBaseCombatCharacter * pPlayer, int iAmmoIndex ) {
        return CGameRules::CanHaveAmmo( boost::python::ptr(pPlayer), iAmmoIndex );
    }

    virtual bool CanHaveAmmo( ::CBaseCombatCharacter * pPlayer, char const * szName ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "CanHaveAmmo: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling CanHaveAmmo( boost::python::ptr(pPlayer), szName ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_CanHaveAmmo = this->get_override( "CanHaveAmmo" );
        if( func_CanHaveAmmo.ptr() != Py_None )
            try {
                return func_CanHaveAmmo( boost::python::ptr(pPlayer), szName );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::CanHaveAmmo( boost::python::ptr(pPlayer), szName );
            }
        else
            return this->CGameRules::CanHaveAmmo( boost::python::ptr(pPlayer), szName );
    }
    
    bool default_CanHaveAmmo( ::CBaseCombatCharacter * pPlayer, char const * szName ) {
        return CGameRules::CanHaveAmmo( boost::python::ptr(pPlayer), szName );
    }

    virtual void ChangePlayerTeam( ::CBasePlayer * pPlayer, char const * pTeamName, bool bKill, bool bGib ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ChangePlayerTeam: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ChangePlayerTeam( boost::python::ptr(pPlayer), pTeamName, bKill, bGib ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ChangePlayerTeam = this->get_override( "ChangePlayerTeam" );
        if( func_ChangePlayerTeam.ptr() != Py_None )
            try {
                func_ChangePlayerTeam( boost::python::ptr(pPlayer), pTeamName, bKill, bGib );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::ChangePlayerTeam( boost::python::ptr(pPlayer), pTeamName, bKill, bGib );
            }
        else
            this->CGameRules::ChangePlayerTeam( boost::python::ptr(pPlayer), pTeamName, bKill, bGib );
    }
    
    void default_ChangePlayerTeam( ::CBasePlayer * pPlayer, char const * pTeamName, bool bKill, bool bGib ) {
        CGameRules::ChangePlayerTeam( boost::python::ptr(pPlayer), pTeamName, bKill, bGib );
    }

    virtual void CheckChatText( ::CBasePlayer * pPlayer, char * pText ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "CheckChatText: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling CheckChatText( boost::python::ptr(pPlayer), pText ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_CheckChatText = this->get_override( "CheckChatText" );
        if( func_CheckChatText.ptr() != Py_None )
            try {
                func_CheckChatText( boost::python::ptr(pPlayer), pText );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::CheckChatText( boost::python::ptr(pPlayer), pText );
            }
        else
            this->CGameRules::CheckChatText( boost::python::ptr(pPlayer), pText );
    }
    
    void default_CheckChatText( ::CBasePlayer * pPlayer, char * pText ) {
        CGameRules::CheckChatText( boost::python::ptr(pPlayer), pText );
    }

    virtual void CheckHaptics( ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "CheckHaptics: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling CheckHaptics( boost::python::ptr(pPlayer) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_CheckHaptics = this->get_override( "CheckHaptics" );
        if( func_CheckHaptics.ptr() != Py_None )
            try {
                func_CheckHaptics( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::CheckHaptics( boost::python::ptr(pPlayer) );
            }
        else
            this->CGameRules::CheckHaptics( boost::python::ptr(pPlayer) );
    }
    
    void default_CheckHaptics( ::CBasePlayer * pPlayer ) {
        CGameRules::CheckHaptics( boost::python::ptr(pPlayer) );
    }

    virtual void ClientSpawned( ::edict_t * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientSpawned: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ClientSpawned( boost::python::ptr(pPlayer) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientSpawned = this->get_override( "ClientSpawned" );
        if( func_ClientSpawned.ptr() != Py_None )
            try {
                func_ClientSpawned( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::ClientSpawned( boost::python::ptr(pPlayer) );
            }
        else
            this->CGameRules::ClientSpawned( boost::python::ptr(pPlayer) );
    }
    
    void default_ClientSpawned( ::edict_t * pPlayer ) {
        CGameRules::ClientSpawned( boost::python::ptr(pPlayer) );
    }

    virtual void CreateCustomNetworkStringTables(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "CreateCustomNetworkStringTables: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling CreateCustomNetworkStringTables(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_CreateCustomNetworkStringTables = this->get_override( "CreateCustomNetworkStringTables" );
        if( func_CreateCustomNetworkStringTables.ptr() != Py_None )
            try {
                func_CreateCustomNetworkStringTables(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::CreateCustomNetworkStringTables(  );
            }
        else
            this->CGameRules::CreateCustomNetworkStringTables(  );
    }
    
    void default_CreateCustomNetworkStringTables(  ) {
        CGameRules::CreateCustomNetworkStringTables( );
    }

    virtual void CreateStandardEntities(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "CreateStandardEntities: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling CreateStandardEntities(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_CreateStandardEntities = this->get_override( "CreateStandardEntities" );
        if( func_CreateStandardEntities.ptr() != Py_None )
            try {
                func_CreateStandardEntities(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::CreateStandardEntities(  );
            }
        else
            this->CGameRules::CreateStandardEntities(  );
    }
    
    void default_CreateStandardEntities(  ) {
        CGameRules::CreateStandardEntities( );
    }

    virtual int DefaultFOV(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "DefaultFOV: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling DefaultFOV(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_DefaultFOV = this->get_override( "DefaultFOV" );
        if( func_DefaultFOV.ptr() != Py_None )
            try {
                return func_DefaultFOV(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::DefaultFOV(  );
            }
        else
            return this->CGameRules::DefaultFOV(  );
    }
    
    int default_DefaultFOV(  ) {
        return CGameRules::DefaultFOV( );
    }

    virtual void EndGameFrame(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "EndGameFrame: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling EndGameFrame(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_EndGameFrame = this->get_override( "EndGameFrame" );
        if( func_EndGameFrame.ptr() != Py_None )
            try {
                func_EndGameFrame(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::EndGameFrame(  );
            }
        else
            this->CGameRules::EndGameFrame(  );
    }
    
    void default_EndGameFrame(  ) {
        CGameRules::EndGameFrame( );
    }

    virtual bool FlPlayerFallDeathDoesScreenFade( ::CBasePlayer * pl ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FlPlayerFallDeathDoesScreenFade: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FlPlayerFallDeathDoesScreenFade( boost::python::ptr(pl) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FlPlayerFallDeathDoesScreenFade = this->get_override( "FlPlayerFallDeathDoesScreenFade" );
        if( func_FlPlayerFallDeathDoesScreenFade.ptr() != Py_None )
            try {
                return func_FlPlayerFallDeathDoesScreenFade( boost::python::ptr(pl) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::FlPlayerFallDeathDoesScreenFade( boost::python::ptr(pl) );
            }
        else
            return this->CGameRules::FlPlayerFallDeathDoesScreenFade( boost::python::ptr(pl) );
    }
    
    bool default_FlPlayerFallDeathDoesScreenFade( ::CBasePlayer * pl ) {
        return CGameRules::FlPlayerFallDeathDoesScreenFade( boost::python::ptr(pl) );
    }

    virtual float GetAmmoQuantityScale( int iAmmoIndex ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetAmmoQuantityScale: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetAmmoQuantityScale( iAmmoIndex ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetAmmoQuantityScale = this->get_override( "GetAmmoQuantityScale" );
        if( func_GetAmmoQuantityScale.ptr() != Py_None )
            try {
                return func_GetAmmoQuantityScale( iAmmoIndex );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetAmmoQuantityScale( iAmmoIndex );
            }
        else
            return this->CGameRules::GetAmmoQuantityScale( iAmmoIndex );
    }
    
    float default_GetAmmoQuantityScale( int iAmmoIndex ) {
        return CGameRules::GetAmmoQuantityScale( iAmmoIndex );
    }

    virtual int GetAutoAimMode(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetAutoAimMode: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetAutoAimMode(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetAutoAimMode = this->get_override( "GetAutoAimMode" );
        if( func_GetAutoAimMode.ptr() != Py_None )
            try {
                return func_GetAutoAimMode(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetAutoAimMode(  );
            }
        else
            return this->CGameRules::GetAutoAimMode(  );
    }
    
    int default_GetAutoAimMode(  ) {
        return CGameRules::GetAutoAimMode( );
    }

    virtual float GetAutoAimScale( ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetAutoAimScale: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetAutoAimScale( boost::python::ptr(pPlayer) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetAutoAimScale = this->get_override( "GetAutoAimScale" );
        if( func_GetAutoAimScale.ptr() != Py_None )
            try {
                return func_GetAutoAimScale( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetAutoAimScale( boost::python::ptr(pPlayer) );
            }
        else
            return this->CGameRules::GetAutoAimScale( boost::python::ptr(pPlayer) );
    }
    
    float default_GetAutoAimScale( ::CBasePlayer * pPlayer ) {
        return CGameRules::GetAutoAimScale( boost::python::ptr(pPlayer) );
    }

    virtual char const * GetChatFormat( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetChatFormat: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetChatFormat( bTeamOnly, boost::python::ptr(pPlayer) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetChatFormat = this->get_override( "GetChatFormat" );
        if( func_GetChatFormat.ptr() != Py_None )
            try {
                return func_GetChatFormat( bTeamOnly, boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetChatFormat( bTeamOnly, boost::python::ptr(pPlayer) );
            }
        else
            return this->CGameRules::GetChatFormat( bTeamOnly, boost::python::ptr(pPlayer) );
    }
    
    char const * default_GetChatFormat( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        return CGameRules::GetChatFormat( bTeamOnly, boost::python::ptr(pPlayer) );
    }

    virtual char const * GetChatLocation( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetChatLocation: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetChatLocation( bTeamOnly, boost::python::ptr(pPlayer) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetChatLocation = this->get_override( "GetChatLocation" );
        if( func_GetChatLocation.ptr() != Py_None )
            try {
                return func_GetChatLocation( bTeamOnly, boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetChatLocation( bTeamOnly, boost::python::ptr(pPlayer) );
            }
        else
            return this->CGameRules::GetChatLocation( bTeamOnly, boost::python::ptr(pPlayer) );
    }
    
    char const * default_GetChatLocation( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        return CGameRules::GetChatLocation( bTeamOnly, boost::python::ptr(pPlayer) );
    }

    virtual char const * GetChatPrefix( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetChatPrefix: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetChatPrefix( bTeamOnly, boost::python::ptr(pPlayer) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetChatPrefix = this->get_override( "GetChatPrefix" );
        if( func_GetChatPrefix.ptr() != Py_None )
            try {
                return func_GetChatPrefix( bTeamOnly, boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetChatPrefix( bTeamOnly, boost::python::ptr(pPlayer) );
            }
        else
            return this->CGameRules::GetChatPrefix( bTeamOnly, boost::python::ptr(pPlayer) );
    }
    
    char const * default_GetChatPrefix( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        return CGameRules::GetChatPrefix( bTeamOnly, boost::python::ptr(pPlayer) );
    }

    virtual char const * GetDamageCustomString( ::CTakeDamageInfo const & info ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetDamageCustomString: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetDamageCustomString( boost::ref(info) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetDamageCustomString = this->get_override( "GetDamageCustomString" );
        if( func_GetDamageCustomString.ptr() != Py_None )
            try {
                return func_GetDamageCustomString( boost::ref(info) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetDamageCustomString( boost::ref(info) );
            }
        else
            return this->CGameRules::GetDamageCustomString( boost::ref(info) );
    }
    
    char const * default_GetDamageCustomString( ::CTakeDamageInfo const & info ) {
        return CGameRules::GetDamageCustomString( boost::ref(info) );
    }

    virtual float GetDamageMultiplier(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetDamageMultiplier: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetDamageMultiplier(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetDamageMultiplier = this->get_override( "GetDamageMultiplier" );
        if( func_GetDamageMultiplier.ptr() != Py_None )
            try {
                return func_GetDamageMultiplier(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetDamageMultiplier(  );
            }
        else
            return this->CGameRules::GetDamageMultiplier(  );
    }
    
    float default_GetDamageMultiplier(  ) {
        return CGameRules::GetDamageMultiplier( );
    }

    virtual char const * GetGameDescription(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetGameDescription: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetGameDescription(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetGameDescription = this->get_override( "GetGameDescription" );
        if( func_GetGameDescription.ptr() != Py_None )
            try {
                return func_GetGameDescription(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetGameDescription(  );
            }
        else
            return this->CGameRules::GetGameDescription(  );
    }
    
    char const * default_GetGameDescription(  ) {
        return CGameRules::GetGameDescription( );
    }

    virtual int GetGameType(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetGameType: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetGameType(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetGameType = this->get_override( "GetGameType" );
        if( func_GetGameType.ptr() != Py_None )
            try {
                return func_GetGameType(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetGameType(  );
            }
        else
            return this->CGameRules::GetGameType(  );
    }
    
    int default_GetGameType(  ) {
        return CGameRules::GetGameType( );
    }

    virtual char const * GetGameTypeName(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetGameTypeName: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetGameTypeName(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetGameTypeName = this->get_override( "GetGameTypeName" );
        if( func_GetGameTypeName.ptr() != Py_None )
            try {
                return func_GetGameTypeName(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetGameTypeName(  );
            }
        else
            return this->CGameRules::GetGameTypeName(  );
    }
    
    char const * default_GetGameTypeName(  ) {
        return CGameRules::GetGameTypeName( );
    }

    virtual char const * GetIndexedTeamName( int teamIndex ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetIndexedTeamName: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetIndexedTeamName( teamIndex ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetIndexedTeamName = this->get_override( "GetIndexedTeamName" );
        if( func_GetIndexedTeamName.ptr() != Py_None )
            try {
                return func_GetIndexedTeamName( teamIndex );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetIndexedTeamName( teamIndex );
            }
        else
            return this->CGameRules::GetIndexedTeamName( teamIndex );
    }
    
    char const * default_GetIndexedTeamName( int teamIndex ) {
        return CGameRules::GetIndexedTeamName( teamIndex );
    }

    virtual int GetSkillLevel(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetSkillLevel: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetSkillLevel(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetSkillLevel = this->get_override( "GetSkillLevel" );
        if( func_GetSkillLevel.ptr() != Py_None )
            try {
                return func_GetSkillLevel(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetSkillLevel(  );
            }
        else
            return this->CGameRules::GetSkillLevel(  );
    }
    
    int default_GetSkillLevel(  ) {
        return CGameRules::GetSkillLevel( );
    }

    virtual int GetTeamIndex( char const * pTeamName ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetTeamIndex: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetTeamIndex( pTeamName ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetTeamIndex = this->get_override( "GetTeamIndex" );
        if( func_GetTeamIndex.ptr() != Py_None )
            try {
                return func_GetTeamIndex( pTeamName );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetTeamIndex( pTeamName );
            }
        else
            return this->CGameRules::GetTeamIndex( pTeamName );
    }
    
    int default_GetTeamIndex( char const * pTeamName ) {
        return CGameRules::GetTeamIndex( pTeamName );
    }

    virtual bool InRoundRestart(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "InRoundRestart: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling InRoundRestart(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_InRoundRestart = this->get_override( "InRoundRestart" );
        if( func_InRoundRestart.ptr() != Py_None )
            try {
                return func_InRoundRestart(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::InRoundRestart(  );
            }
        else
            return this->CGameRules::InRoundRestart(  );
    }
    
    bool default_InRoundRestart(  ) {
        return CGameRules::InRoundRestart( );
    }

    virtual void InitDefaultAIRelationships(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "InitDefaultAIRelationships: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling InitDefaultAIRelationships(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_InitDefaultAIRelationships = this->get_override( "InitDefaultAIRelationships" );
        if( func_InitDefaultAIRelationships.ptr() != Py_None )
            try {
                func_InitDefaultAIRelationships(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::InitDefaultAIRelationships(  );
            }
        else
            this->CGameRules::InitDefaultAIRelationships(  );
    }
    
    void default_InitDefaultAIRelationships(  ) {
        CGameRules::InitDefaultAIRelationships( );
    }

    virtual void InitGamerules(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "InitGamerules: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling InitGamerules(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_InitGamerules = this->get_override( "InitGamerules" );
        if( func_InitGamerules.ptr() != Py_None )
            try {
                func_InitGamerules(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::InitGamerules(  );
            }
        else
            this->CGameRules::InitGamerules(  );
    }
    
    void default_InitGamerules(  ) {
        CGameRules::InitGamerules( );
    }

    virtual bool IsConnectedUserInfoChangeAllowed( ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsConnectedUserInfoChangeAllowed: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsConnectedUserInfoChangeAllowed = this->get_override( "IsConnectedUserInfoChangeAllowed" );
        if( func_IsConnectedUserInfoChangeAllowed.ptr() != Py_None )
            try {
                return func_IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) );
            }
        else
            return this->CGameRules::IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) );
    }
    
    bool default_IsConnectedUserInfoChangeAllowed( ::CBasePlayer * pPlayer ) {
        return CGameRules::IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) );
    }

    virtual bool IsHolidayActive( int eHoliday ) const  {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsHolidayActive: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsHolidayActive( eHoliday ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsHolidayActive = this->get_override( "IsHolidayActive" );
        if( func_IsHolidayActive.ptr() != Py_None )
            try {
                return func_IsHolidayActive( eHoliday );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::IsHolidayActive( eHoliday );
            }
        else
            return this->CGameRules::IsHolidayActive( eHoliday );
    }
    
    bool default_IsHolidayActive( int eHoliday ) const  {
        return CGameRules::IsHolidayActive( eHoliday );
    }

    virtual bool IsSkillLevel( int iLevel ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsSkillLevel: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsSkillLevel( iLevel ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsSkillLevel = this->get_override( "IsSkillLevel" );
        if( func_IsSkillLevel.ptr() != Py_None )
            try {
                return func_IsSkillLevel( iLevel );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::IsSkillLevel( iLevel );
            }
        else
            return this->CGameRules::IsSkillLevel( iLevel );
    }
    
    bool default_IsSkillLevel( int iLevel ) {
        return CGameRules::IsSkillLevel( iLevel );
    }

    virtual bool IsSpawnPointValid( ::CBaseEntity * pSpot, ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsSpawnPointValid: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsSpawnPointValid( boost::python::ptr(pSpot), boost::python::ptr(pPlayer) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsSpawnPointValid = this->get_override( "IsSpawnPointValid" );
        if( func_IsSpawnPointValid.ptr() != Py_None )
            try {
                return func_IsSpawnPointValid( boost::python::ptr(pSpot), boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::IsSpawnPointValid( boost::python::ptr(pSpot), boost::python::ptr(pPlayer) );
            }
        else
            return this->CGameRules::IsSpawnPointValid( boost::python::ptr(pSpot), boost::python::ptr(pPlayer) );
    }
    
    bool default_IsSpawnPointValid( ::CBaseEntity * pSpot, ::CBasePlayer * pPlayer ) {
        return CGameRules::IsSpawnPointValid( boost::python::ptr(pSpot), boost::python::ptr(pPlayer) );
    }

    virtual bool IsTeamplay(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsTeamplay: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsTeamplay(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsTeamplay = this->get_override( "IsTeamplay" );
        if( func_IsTeamplay.ptr() != Py_None )
            try {
                return func_IsTeamplay(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::IsTeamplay(  );
            }
        else
            return this->CGameRules::IsTeamplay(  );
    }
    
    bool default_IsTeamplay(  ) {
        return CGameRules::IsTeamplay( );
    }

    virtual bool IsValidTeam( char const * pTeamName ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsValidTeam: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsValidTeam( pTeamName ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsValidTeam = this->get_override( "IsValidTeam" );
        if( func_IsValidTeam.ptr() != Py_None )
            try {
                return func_IsValidTeam( pTeamName );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::IsValidTeam( pTeamName );
            }
        else
            return this->CGameRules::IsValidTeam( pTeamName );
    }
    
    bool default_IsValidTeam( char const * pTeamName ) {
        return CGameRules::IsValidTeam( pTeamName );
    }

    virtual void LevelShutdown(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdown: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdown(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdown = this->get_override( "LevelShutdown" );
        if( func_LevelShutdown.ptr() != Py_None )
            try {
                func_LevelShutdown(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::LevelShutdown(  );
            }
        else
            this->CGameRules::LevelShutdown(  );
    }
    
    void default_LevelShutdown(  ) {
        CGameRules::LevelShutdown( );
    }

    virtual void MarkAchievement( ::IRecipientFilter & filter, char const * pchAchievementName ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "MarkAchievement: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling MarkAchievement( boost::ref(filter), pchAchievementName ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_MarkAchievement = this->get_override( "MarkAchievement" );
        if( func_MarkAchievement.ptr() != Py_None )
            try {
                func_MarkAchievement( boost::ref(filter), pchAchievementName );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::MarkAchievement( boost::ref(filter), pchAchievementName );
            }
        else
            this->CGameRules::MarkAchievement( boost::ref(filter), pchAchievementName );
    }
    
    void default_MarkAchievement( ::IRecipientFilter & filter, char const * pchAchievementName ) {
        CGameRules::MarkAchievement( boost::ref(filter), pchAchievementName );
    }

    virtual char const * Name(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Name: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Name(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Name = this->get_override( "Name" );
        if( func_Name.ptr() != Py_None )
            try {
                return func_Name(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::Name(  );
            }
        else
            return this->CGameRules::Name(  );
    }
    
    char const * default_Name(  ) {
        return CGameRules::Name( );
    }

    virtual void OnFileReceived( char const * fileName, unsigned int transferID ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnFileReceived: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnFileReceived( fileName, transferID ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnFileReceived = this->get_override( "OnFileReceived" );
        if( func_OnFileReceived.ptr() != Py_None )
            try {
                func_OnFileReceived( fileName, transferID );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::OnFileReceived( fileName, transferID );
            }
        else
            this->CGameRules::OnFileReceived( fileName, transferID );
    }
    
    void default_OnFileReceived( char const * fileName, unsigned int transferID ) {
        CGameRules::OnFileReceived( fileName, transferID );
    }

    virtual void OnNavMeshLoad(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnNavMeshLoad: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnNavMeshLoad(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnNavMeshLoad = this->get_override( "OnNavMeshLoad" );
        if( func_OnNavMeshLoad.ptr() != Py_None )
            try {
                func_OnNavMeshLoad(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::OnNavMeshLoad(  );
            }
        else
            this->CGameRules::OnNavMeshLoad(  );
    }
    
    void default_OnNavMeshLoad(  ) {
        CGameRules::OnNavMeshLoad( );
    }

    virtual void OnSkillLevelChanged( int iNewLevel ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnSkillLevelChanged: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnSkillLevelChanged( iNewLevel ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnSkillLevelChanged = this->get_override( "OnSkillLevelChanged" );
        if( func_OnSkillLevelChanged.ptr() != Py_None )
            try {
                func_OnSkillLevelChanged( iNewLevel );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::OnSkillLevelChanged( iNewLevel );
            }
        else
            this->CGameRules::OnSkillLevelChanged( iNewLevel );
    }
    
    void default_OnSkillLevelChanged( int iNewLevel ) {
        CGameRules::OnSkillLevelChanged( iNewLevel );
    }

    virtual void Precache(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Precache: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Precache(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Precache = this->get_override( "Precache" );
        if( func_Precache.ptr() != Py_None )
            try {
                func_Precache(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::Precache(  );
            }
        else
            this->CGameRules::Precache(  );
    }
    
    void default_Precache(  ) {
        CGameRules::Precache( );
    }

    virtual void ProcessVerboseLogOutput(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ProcessVerboseLogOutput: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ProcessVerboseLogOutput(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ProcessVerboseLogOutput = this->get_override( "ProcessVerboseLogOutput" );
        if( func_ProcessVerboseLogOutput.ptr() != Py_None )
            try {
                func_ProcessVerboseLogOutput(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::ProcessVerboseLogOutput(  );
            }
        else
            this->CGameRules::ProcessVerboseLogOutput(  );
    }
    
    void default_ProcessVerboseLogOutput(  ) {
        CGameRules::ProcessVerboseLogOutput( );
    }

    virtual void RadiusDamage( ::CTakeDamageInfo const & info, ::Vector const & vecSrc, float flRadius, int iClassIgnore, ::CBaseEntity * pEntityIgnore ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "RadiusDamage: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling RadiusDamage( boost::ref(info), boost::ref(vecSrc), flRadius, iClassIgnore, boost::python::ptr(pEntityIgnore) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_RadiusDamage = this->get_override( "RadiusDamage" );
        if( func_RadiusDamage.ptr() != Py_None )
            try {
                func_RadiusDamage( boost::ref(info), boost::ref(vecSrc), flRadius, iClassIgnore, boost::python::ptr(pEntityIgnore) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::RadiusDamage( boost::ref(info), boost::ref(vecSrc), flRadius, iClassIgnore, boost::python::ptr(pEntityIgnore) );
            }
        else
            this->CGameRules::RadiusDamage( boost::ref(info), boost::ref(vecSrc), flRadius, iClassIgnore, boost::python::ptr(pEntityIgnore) );
    }
    
    void default_RadiusDamage( ::CTakeDamageInfo const & info, ::Vector const & vecSrc, float flRadius, int iClassIgnore, ::CBaseEntity * pEntityIgnore ) {
        CGameRules::RadiusDamage( boost::ref(info), boost::ref(vecSrc), flRadius, iClassIgnore, boost::python::ptr(pEntityIgnore) );
    }

    virtual char const * SetDefaultPlayerTeam( ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SetDefaultPlayerTeam: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SetDefaultPlayerTeam( boost::python::ptr(pPlayer) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SetDefaultPlayerTeam = this->get_override( "SetDefaultPlayerTeam" );
        if( func_SetDefaultPlayerTeam.ptr() != Py_None )
            try {
                return func_SetDefaultPlayerTeam( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::SetDefaultPlayerTeam( boost::python::ptr(pPlayer) );
            }
        else
            return this->CGameRules::SetDefaultPlayerTeam( boost::python::ptr(pPlayer) );
    }
    
    char const * default_SetDefaultPlayerTeam( ::CBasePlayer * pPlayer ) {
        return CGameRules::SetDefaultPlayerTeam( boost::python::ptr(pPlayer) );
    }

    virtual void SetSkillLevel( int iLevel ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SetSkillLevel: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SetSkillLevel( iLevel ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SetSkillLevel = this->get_override( "SetSkillLevel" );
        if( func_SetSkillLevel.ptr() != Py_None )
            try {
                func_SetSkillLevel( iLevel );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::SetSkillLevel( iLevel );
            }
        else
            this->CGameRules::SetSkillLevel( iLevel );
    }
    
    void default_SetSkillLevel( int iLevel ) {
        CGameRules::SetSkillLevel( iLevel );
    }

    virtual bool ShouldAutoAim( ::CBasePlayer * pPlayer, ::edict_t * target ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShouldAutoAim: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShouldAutoAim( boost::python::ptr(pPlayer), boost::python::ptr(target) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShouldAutoAim = this->get_override( "ShouldAutoAim" );
        if( func_ShouldAutoAim.ptr() != Py_None )
            try {
                return func_ShouldAutoAim( boost::python::ptr(pPlayer), boost::python::ptr(target) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::ShouldAutoAim( boost::python::ptr(pPlayer), boost::python::ptr(target) );
            }
        else
            return this->CGameRules::ShouldAutoAim( boost::python::ptr(pPlayer), boost::python::ptr(target) );
    }
    
    bool default_ShouldAutoAim( ::CBasePlayer * pPlayer, ::edict_t * target ) {
        return CGameRules::ShouldAutoAim( boost::python::ptr(pPlayer), boost::python::ptr(target) );
    }

    virtual bool ShouldBurningPropsEmitLight(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShouldBurningPropsEmitLight: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShouldBurningPropsEmitLight(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShouldBurningPropsEmitLight = this->get_override( "ShouldBurningPropsEmitLight" );
        if( func_ShouldBurningPropsEmitLight.ptr() != Py_None )
            try {
                return func_ShouldBurningPropsEmitLight(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::ShouldBurningPropsEmitLight(  );
            }
        else
            return this->CGameRules::ShouldBurningPropsEmitLight(  );
    }
    
    bool default_ShouldBurningPropsEmitLight(  ) {
        return CGameRules::ShouldBurningPropsEmitLight( );
    }

    virtual bool ShouldUseRobustRadiusDamage( ::CBaseEntity * pEntity ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShouldUseRobustRadiusDamage: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShouldUseRobustRadiusDamage( boost::python::ptr(pEntity) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShouldUseRobustRadiusDamage = this->get_override( "ShouldUseRobustRadiusDamage" );
        if( func_ShouldUseRobustRadiusDamage.ptr() != Py_None )
            try {
                return func_ShouldUseRobustRadiusDamage( boost::python::ptr(pEntity) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::ShouldUseRobustRadiusDamage( boost::python::ptr(pEntity) );
            }
        else
            return this->CGameRules::ShouldUseRobustRadiusDamage( boost::python::ptr(pEntity) );
    }
    
    bool default_ShouldUseRobustRadiusDamage( ::CBaseEntity * pEntity ) {
        return CGameRules::ShouldUseRobustRadiusDamage( boost::python::ptr(pEntity) );
    }

    virtual void ShutdownGamerules(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShutdownGamerules: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShutdownGamerules(  ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShutdownGamerules = this->get_override( "ShutdownGamerules" );
        if( func_ShutdownGamerules.ptr() != Py_None )
            try {
                func_ShutdownGamerules(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::ShutdownGamerules(  );
            }
        else
            this->CGameRules::ShutdownGamerules(  );
    }
    
    void default_ShutdownGamerules(  ) {
        CGameRules::ShutdownGamerules( );
    }

    virtual void UpdateClientData( ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "UpdateClientData: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling UpdateClientData( boost::python::ptr(pPlayer) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_UpdateClientData = this->get_override( "UpdateClientData" );
        if( func_UpdateClientData.ptr() != Py_None )
            try {
                func_UpdateClientData( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::UpdateClientData( boost::python::ptr(pPlayer) );
            }
        else
            this->CGameRules::UpdateClientData( boost::python::ptr(pPlayer) );
    }
    
    void default_UpdateClientData( ::CBasePlayer * pPlayer ) {
        CGameRules::UpdateClientData( boost::python::ptr(pPlayer) );
    }

    virtual float WeaponTraceEntity( ::CBaseEntity * pEntity, ::Vector const & vecStart, ::Vector const & vecEnd, unsigned int mask, ::trace_t * ptr ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "WeaponTraceEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling WeaponTraceEntity( boost::python::ptr(pEntity), boost::ref(vecStart), boost::ref(vecEnd), mask, boost::python::ptr(ptr) ) of Class: CGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_WeaponTraceEntity = this->get_override( "WeaponTraceEntity" );
        if( func_WeaponTraceEntity.ptr() != Py_None )
            try {
                return func_WeaponTraceEntity( boost::python::ptr(pEntity), boost::ref(vecStart), boost::ref(vecEnd), mask, boost::python::ptr(ptr) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::WeaponTraceEntity( boost::python::ptr(pEntity), boost::ref(vecStart), boost::ref(vecEnd), mask, boost::python::ptr(ptr) );
            }
        else
            return this->CGameRules::WeaponTraceEntity( boost::python::ptr(pEntity), boost::ref(vecStart), boost::ref(vecEnd), mask, boost::python::ptr(ptr) );
    }
    
    float default_WeaponTraceEntity( ::CBaseEntity * pEntity, ::Vector const & vecStart, ::Vector const & vecEnd, unsigned int mask, ::trace_t * ptr ) {
        return CGameRules::WeaponTraceEntity( boost::python::ptr(pEntity), boost::ref(vecStart), boost::ref(vecEnd), mask, boost::python::ptr(ptr) );
    }

    virtual PyObject *GetPySelf() const { return boost::python::detail::wrapper_base_::get_owner(*this); }

};

void register_CMultiplayRules_class(){

    { //::CMultiplayRules
        typedef bp::class_< CMultiplayRules_wrapper, bp::bases< CGameRules >, boost::noncopyable > CMultiplayRules_exposer_t;
        CMultiplayRules_exposer_t CMultiplayRules_exposer = CMultiplayRules_exposer_t( "CMultiplayRules", bp::no_init );
        bp::scope CMultiplayRules_scope( CMultiplayRules_exposer );
        bp::class_< CMultiplayRules::ResponseRules_t, boost::noncopyable >( "ResponseRules_t", bp::no_init )    
            .def_readwrite( "m_ResponseSystems", &CMultiplayRules::ResponseRules_t::m_ResponseSystems );
        CMultiplayRules_exposer.def( bp::init< >() );
        { //::CMultiplayRules::AllowAutoTargetCrosshair
        
            typedef bool ( ::CMultiplayRules::*AllowAutoTargetCrosshair_function_type )(  ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_AllowAutoTargetCrosshair_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "AllowAutoTargetCrosshair"
                , AllowAutoTargetCrosshair_function_type(&::CMultiplayRules::AllowAutoTargetCrosshair)
                , default_AllowAutoTargetCrosshair_function_type(&CMultiplayRules_wrapper::default_AllowAutoTargetCrosshair) );
        
        }
        { //::CMultiplayRules::AllowDamage
        
            typedef bool ( ::CMultiplayRules::*AllowDamage_function_type )( ::CBaseEntity *,::CTakeDamageInfo const & ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_AllowDamage_function_type )( ::CBaseEntity *,::CTakeDamageInfo const & ) ;
            
            CMultiplayRules_exposer.def( 
                "AllowDamage"
                , AllowDamage_function_type(&::CMultiplayRules::AllowDamage)
                , default_AllowDamage_function_type(&CMultiplayRules_wrapper::default_AllowDamage)
                , ( bp::arg("pVictim"), bp::arg("info") ) );
        
        }
        { //::CMultiplayRules::CanHaveItem
        
            typedef bool ( ::CMultiplayRules::*CanHaveItem_function_type )( ::CBasePlayer *,::CItem * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_CanHaveItem_function_type )( ::CBasePlayer *,::CItem * ) ;
            
            CMultiplayRules_exposer.def( 
                "CanHaveItem"
                , CanHaveItem_function_type(&::CMultiplayRules::CanHaveItem)
                , default_CanHaveItem_function_type(&CMultiplayRules_wrapper::default_CanHaveItem)
                , ( bp::arg("pPlayer"), bp::arg("pItem") ) );
        
        }
        { //::CMultiplayRules::CanHavePlayerItem
        
            typedef bool ( ::CMultiplayRules::*CanHavePlayerItem_function_type )( ::CBasePlayer *,::CBaseCombatWeapon * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_CanHavePlayerItem_function_type )( ::CBasePlayer *,::CBaseCombatWeapon * ) ;
            
            CMultiplayRules_exposer.def( 
                "CanHavePlayerItem"
                , CanHavePlayerItem_function_type(&::CMultiplayRules::CanHavePlayerItem)
                , default_CanHavePlayerItem_function_type(&CMultiplayRules_wrapper::default_CanHavePlayerItem)
                , ( bp::arg("pPlayer"), bp::arg("pWeapon") ) );
        
        }
        { //::CMultiplayRules::ChangeLevel
        
            typedef void ( ::CMultiplayRules::*ChangeLevel_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_ChangeLevel_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "ChangeLevel"
                , ChangeLevel_function_type(&::CMultiplayRules::ChangeLevel)
                , default_ChangeLevel_function_type(&CMultiplayRules_wrapper::default_ChangeLevel) );
        
        }
        { //::CMultiplayRules::ClientCommand
        
            typedef bool ( ::CMultiplayRules::*ClientCommand_function_type )( ::CBaseEntity *,::CCommand const & ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_ClientCommand_function_type )( ::CBaseEntity *,::CCommand const & ) ;
            
            CMultiplayRules_exposer.def( 
                "ClientCommand"
                , ClientCommand_function_type(&::CMultiplayRules::ClientCommand)
                , default_ClientCommand_function_type(&CMultiplayRules_wrapper::default_ClientCommand)
                , ( bp::arg("pEdict"), bp::arg("args") ) );
        
        }
        { //::CMultiplayRules::ClientCommandKeyValues
        
            typedef void ( ::CMultiplayRules::*ClientCommandKeyValues_function_type )( ::edict_t *,::KeyValues * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_ClientCommandKeyValues_function_type )( ::edict_t *,::KeyValues * ) ;
            
            CMultiplayRules_exposer.def( 
                "ClientCommandKeyValues"
                , ClientCommandKeyValues_function_type(&::CMultiplayRules::ClientCommandKeyValues)
                , default_ClientCommandKeyValues_function_type(&CMultiplayRules_wrapper::default_ClientCommandKeyValues)
                , ( bp::arg("pEntity"), bp::arg("pKeyValues") ) );
        
        }
        { //::CMultiplayRules::ClientConnected
        
            typedef bool ( ::CMultiplayRules::*ClientConnected_function_type )( ::edict_t *,char const *,char const *,char *,int ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_ClientConnected_function_type )( ::edict_t *,char const *,char const *,char *,int ) ;
            
            CMultiplayRules_exposer.def( 
                "ClientConnected"
                , ClientConnected_function_type(&::CMultiplayRules::ClientConnected)
                , default_ClientConnected_function_type(&CMultiplayRules_wrapper::default_ClientConnected)
                , ( bp::arg("pEntity"), bp::arg("pszName"), bp::arg("pszAddress"), bp::arg("reject"), bp::arg("maxrejectlen") ) );
        
        }
        { //::CMultiplayRules::ClientDisconnected
        
            typedef void ( ::CMultiplayRules::*ClientDisconnected_function_type )( ::edict_t * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_ClientDisconnected_function_type )( ::edict_t * ) ;
            
            CMultiplayRules_exposer.def( 
                "ClientDisconnected"
                , ClientDisconnected_function_type(&::CMultiplayRules::ClientDisconnected)
                , default_ClientDisconnected_function_type(&CMultiplayRules_wrapper::default_ClientDisconnected)
                , ( bp::arg("pClient") ) );
        
        }
        { //::CMultiplayRules::ClientSettingsChanged
        
            typedef void ( ::CMultiplayRules::*ClientSettingsChanged_function_type )( ::CBasePlayer * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_ClientSettingsChanged_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "ClientSettingsChanged"
                , ClientSettingsChanged_function_type(&::CMultiplayRules::ClientSettingsChanged)
                , default_ClientSettingsChanged_function_type(&CMultiplayRules_wrapper::default_ClientSettingsChanged)
                , ( bp::arg("pPlayer") ) );
        
        }
        { //::CMultiplayRules::Damage_GetNoPhysicsForce
        
            typedef int ( ::CMultiplayRules::*Damage_GetNoPhysicsForce_function_type )(  ) ;
            typedef int ( CMultiplayRules_wrapper::*default_Damage_GetNoPhysicsForce_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "Damage_GetNoPhysicsForce"
                , Damage_GetNoPhysicsForce_function_type(&::CMultiplayRules::Damage_GetNoPhysicsForce)
                , default_Damage_GetNoPhysicsForce_function_type(&CMultiplayRules_wrapper::default_Damage_GetNoPhysicsForce) );
        
        }
        { //::CMultiplayRules::Damage_GetShouldGibCorpse
        
            typedef int ( ::CMultiplayRules::*Damage_GetShouldGibCorpse_function_type )(  ) ;
            typedef int ( CMultiplayRules_wrapper::*default_Damage_GetShouldGibCorpse_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "Damage_GetShouldGibCorpse"
                , Damage_GetShouldGibCorpse_function_type(&::CMultiplayRules::Damage_GetShouldGibCorpse)
                , default_Damage_GetShouldGibCorpse_function_type(&CMultiplayRules_wrapper::default_Damage_GetShouldGibCorpse) );
        
        }
        { //::CMultiplayRules::Damage_GetShouldNotBleed
        
            typedef int ( ::CMultiplayRules::*Damage_GetShouldNotBleed_function_type )(  ) ;
            typedef int ( CMultiplayRules_wrapper::*default_Damage_GetShouldNotBleed_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "Damage_GetShouldNotBleed"
                , Damage_GetShouldNotBleed_function_type(&::CMultiplayRules::Damage_GetShouldNotBleed)
                , default_Damage_GetShouldNotBleed_function_type(&CMultiplayRules_wrapper::default_Damage_GetShouldNotBleed) );
        
        }
        { //::CMultiplayRules::Damage_GetShowOnHud
        
            typedef int ( ::CMultiplayRules::*Damage_GetShowOnHud_function_type )(  ) ;
            typedef int ( CMultiplayRules_wrapper::*default_Damage_GetShowOnHud_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "Damage_GetShowOnHud"
                , Damage_GetShowOnHud_function_type(&::CMultiplayRules::Damage_GetShowOnHud)
                , default_Damage_GetShowOnHud_function_type(&CMultiplayRules_wrapper::default_Damage_GetShowOnHud) );
        
        }
        { //::CMultiplayRules::Damage_GetTimeBased
        
            typedef int ( ::CMultiplayRules::*Damage_GetTimeBased_function_type )(  ) ;
            typedef int ( CMultiplayRules_wrapper::*default_Damage_GetTimeBased_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "Damage_GetTimeBased"
                , Damage_GetTimeBased_function_type(&::CMultiplayRules::Damage_GetTimeBased)
                , default_Damage_GetTimeBased_function_type(&CMultiplayRules_wrapper::default_Damage_GetTimeBased) );
        
        }
        { //::CMultiplayRules::Damage_IsTimeBased
        
            typedef bool ( ::CMultiplayRules::*Damage_IsTimeBased_function_type )( int ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_Damage_IsTimeBased_function_type )( int ) ;
            
            CMultiplayRules_exposer.def( 
                "Damage_IsTimeBased"
                , Damage_IsTimeBased_function_type(&::CMultiplayRules::Damage_IsTimeBased)
                , default_Damage_IsTimeBased_function_type(&CMultiplayRules_wrapper::default_Damage_IsTimeBased)
                , ( bp::arg("iDmgType") ) );
        
        }
        { //::CMultiplayRules::Damage_NoPhysicsForce
        
            typedef bool ( ::CMultiplayRules::*Damage_NoPhysicsForce_function_type )( int ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_Damage_NoPhysicsForce_function_type )( int ) ;
            
            CMultiplayRules_exposer.def( 
                "Damage_NoPhysicsForce"
                , Damage_NoPhysicsForce_function_type(&::CMultiplayRules::Damage_NoPhysicsForce)
                , default_Damage_NoPhysicsForce_function_type(&CMultiplayRules_wrapper::default_Damage_NoPhysicsForce)
                , ( bp::arg("iDmgType") ) );
        
        }
        { //::CMultiplayRules::Damage_ShouldGibCorpse
        
            typedef bool ( ::CMultiplayRules::*Damage_ShouldGibCorpse_function_type )( int ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_Damage_ShouldGibCorpse_function_type )( int ) ;
            
            CMultiplayRules_exposer.def( 
                "Damage_ShouldGibCorpse"
                , Damage_ShouldGibCorpse_function_type(&::CMultiplayRules::Damage_ShouldGibCorpse)
                , default_Damage_ShouldGibCorpse_function_type(&CMultiplayRules_wrapper::default_Damage_ShouldGibCorpse)
                , ( bp::arg("iDmgType") ) );
        
        }
        { //::CMultiplayRules::Damage_ShouldNotBleed
        
            typedef bool ( ::CMultiplayRules::*Damage_ShouldNotBleed_function_type )( int ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_Damage_ShouldNotBleed_function_type )( int ) ;
            
            CMultiplayRules_exposer.def( 
                "Damage_ShouldNotBleed"
                , Damage_ShouldNotBleed_function_type(&::CMultiplayRules::Damage_ShouldNotBleed)
                , default_Damage_ShouldNotBleed_function_type(&CMultiplayRules_wrapper::default_Damage_ShouldNotBleed)
                , ( bp::arg("iDmgType") ) );
        
        }
        { //::CMultiplayRules::Damage_ShowOnHUD
        
            typedef bool ( ::CMultiplayRules::*Damage_ShowOnHUD_function_type )( int ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_Damage_ShowOnHUD_function_type )( int ) ;
            
            CMultiplayRules_exposer.def( 
                "Damage_ShowOnHUD"
                , Damage_ShowOnHUD_function_type(&::CMultiplayRules::Damage_ShowOnHUD)
                , default_Damage_ShowOnHUD_function_type(&CMultiplayRules_wrapper::default_Damage_ShowOnHUD)
                , ( bp::arg("iDmgType") ) );
        
        }
        { //::CMultiplayRules::DeadPlayerAmmo
        
            typedef int ( ::CMultiplayRules::*DeadPlayerAmmo_function_type )( ::CBasePlayer * ) ;
            typedef int ( CMultiplayRules_wrapper::*default_DeadPlayerAmmo_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "DeadPlayerAmmo"
                , DeadPlayerAmmo_function_type(&::CMultiplayRules::DeadPlayerAmmo)
                , default_DeadPlayerAmmo_function_type(&CMultiplayRules_wrapper::default_DeadPlayerAmmo)
                , ( bp::arg("pPlayer") ) );
        
        }
        { //::CMultiplayRules::DeadPlayerWeapons
        
            typedef int ( ::CMultiplayRules::*DeadPlayerWeapons_function_type )( ::CBasePlayer * ) ;
            typedef int ( CMultiplayRules_wrapper::*default_DeadPlayerWeapons_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "DeadPlayerWeapons"
                , DeadPlayerWeapons_function_type(&::CMultiplayRules::DeadPlayerWeapons)
                , default_DeadPlayerWeapons_function_type(&CMultiplayRules_wrapper::default_DeadPlayerWeapons)
                , ( bp::arg("pPlayer") ) );
        
        }
        { //::CMultiplayRules::DeathNotice
        
            typedef void ( ::CMultiplayRules::*DeathNotice_function_type )( ::CBasePlayer *,::CTakeDamageInfo const & ) ;
            typedef void ( CMultiplayRules_wrapper::*default_DeathNotice_function_type )( ::CBasePlayer *,::CTakeDamageInfo const & ) ;
            
            CMultiplayRules_exposer.def( 
                "DeathNotice"
                , DeathNotice_function_type(&::CMultiplayRules::DeathNotice)
                , default_DeathNotice_function_type(&CMultiplayRules_wrapper::default_DeathNotice)
                , ( bp::arg("pVictim"), bp::arg("info") ) );
        
        }
        { //::CMultiplayRules::DetermineMapCycleFilename
        
            typedef void ( *DetermineMapCycleFilename_function_type )( char *,int,bool );
            
            CMultiplayRules_exposer.def( 
                "DetermineMapCycleFilename"
                , DetermineMapCycleFilename_function_type( &::CMultiplayRules::DetermineMapCycleFilename )
                , ( bp::arg("pszResult"), bp::arg("nSizeResult"), bp::arg("bForceSpew") ) );
        
        }
        { //::CMultiplayRules::EndMultiplayerGame
        
            typedef void ( ::CMultiplayRules::*EndMultiplayerGame_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_EndMultiplayerGame_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "EndMultiplayerGame"
                , EndMultiplayerGame_function_type(&::CMultiplayRules::EndMultiplayerGame)
                , default_EndMultiplayerGame_function_type(&CMultiplayRules_wrapper::default_EndMultiplayerGame) );
        
        }
        { //::CMultiplayRules::FAllowFlashlight
        
            typedef bool ( ::CMultiplayRules::*FAllowFlashlight_function_type )(  ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_FAllowFlashlight_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "FAllowFlashlight"
                , FAllowFlashlight_function_type(&::CMultiplayRules::FAllowFlashlight)
                , default_FAllowFlashlight_function_type(&CMultiplayRules_wrapper::default_FAllowFlashlight) );
        
        }
        { //::CMultiplayRules::FAllowNPCs
        
            typedef bool ( ::CMultiplayRules::*FAllowNPCs_function_type )(  ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_FAllowNPCs_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "FAllowNPCs"
                , FAllowNPCs_function_type(&::CMultiplayRules::FAllowNPCs)
                , default_FAllowNPCs_function_type(&CMultiplayRules_wrapper::default_FAllowNPCs) );
        
        }
        { //::CMultiplayRules::FPlayerCanRespawn
        
            typedef bool ( ::CMultiplayRules::*FPlayerCanRespawn_function_type )( ::CBasePlayer * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_FPlayerCanRespawn_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "FPlayerCanRespawn"
                , FPlayerCanRespawn_function_type(&::CMultiplayRules::FPlayerCanRespawn)
                , default_FPlayerCanRespawn_function_type(&CMultiplayRules_wrapper::default_FPlayerCanRespawn)
                , ( bp::arg("pPlayer") ) );
        
        }
        { //::CMultiplayRules::FPlayerCanTakeDamage
        
            typedef bool ( ::CMultiplayRules::*FPlayerCanTakeDamage_function_type )( ::CBasePlayer *,::CBaseEntity * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_FPlayerCanTakeDamage_function_type )( ::CBasePlayer *,::CBaseEntity * ) ;
            
            CMultiplayRules_exposer.def( 
                "FPlayerCanTakeDamage"
                , FPlayerCanTakeDamage_function_type(&::CMultiplayRules::FPlayerCanTakeDamage)
                , default_FPlayerCanTakeDamage_function_type(&CMultiplayRules_wrapper::default_FPlayerCanTakeDamage)
                , ( bp::arg("pPlayer"), bp::arg("pAttacker") ) );
        
        }
        { //::CMultiplayRules::FShouldSwitchWeapon
        
            typedef bool ( ::CMultiplayRules::*FShouldSwitchWeapon_function_type )( ::CBasePlayer *,::CBaseCombatWeapon * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_FShouldSwitchWeapon_function_type )( ::CBasePlayer *,::CBaseCombatWeapon * ) ;
            
            CMultiplayRules_exposer.def( 
                "FShouldSwitchWeapon"
                , FShouldSwitchWeapon_function_type(&::CMultiplayRules::FShouldSwitchWeapon)
                , default_FShouldSwitchWeapon_function_type(&CMultiplayRules_wrapper::default_FShouldSwitchWeapon)
                , ( bp::arg("pPlayer"), bp::arg("pWeapon") ) );
        
        }
        { //::CMultiplayRules::FlHEVChargerRechargeTime
        
            typedef float ( ::CMultiplayRules::*FlHEVChargerRechargeTime_function_type )(  ) ;
            typedef float ( CMultiplayRules_wrapper::*default_FlHEVChargerRechargeTime_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "FlHEVChargerRechargeTime"
                , FlHEVChargerRechargeTime_function_type(&::CMultiplayRules::FlHEVChargerRechargeTime)
                , default_FlHEVChargerRechargeTime_function_type(&CMultiplayRules_wrapper::default_FlHEVChargerRechargeTime) );
        
        }
        { //::CMultiplayRules::FlHealthChargerRechargeTime
        
            typedef float ( ::CMultiplayRules::*FlHealthChargerRechargeTime_function_type )(  ) ;
            typedef float ( CMultiplayRules_wrapper::*default_FlHealthChargerRechargeTime_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "FlHealthChargerRechargeTime"
                , FlHealthChargerRechargeTime_function_type(&::CMultiplayRules::FlHealthChargerRechargeTime)
                , default_FlHealthChargerRechargeTime_function_type(&CMultiplayRules_wrapper::default_FlHealthChargerRechargeTime) );
        
        }
        { //::CMultiplayRules::FlItemRespawnTime
        
            typedef float ( ::CMultiplayRules::*FlItemRespawnTime_function_type )( ::CItem * ) ;
            typedef float ( CMultiplayRules_wrapper::*default_FlItemRespawnTime_function_type )( ::CItem * ) ;
            
            CMultiplayRules_exposer.def( 
                "FlItemRespawnTime"
                , FlItemRespawnTime_function_type(&::CMultiplayRules::FlItemRespawnTime)
                , default_FlItemRespawnTime_function_type(&CMultiplayRules_wrapper::default_FlItemRespawnTime)
                , ( bp::arg("pItem") ) );
        
        }
        { //::CMultiplayRules::FlPlayerFallDamage
        
            typedef float ( ::CMultiplayRules::*FlPlayerFallDamage_function_type )( ::CBasePlayer * ) ;
            typedef float ( CMultiplayRules_wrapper::*default_FlPlayerFallDamage_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "FlPlayerFallDamage"
                , FlPlayerFallDamage_function_type(&::CMultiplayRules::FlPlayerFallDamage)
                , default_FlPlayerFallDamage_function_type(&CMultiplayRules_wrapper::default_FlPlayerFallDamage)
                , ( bp::arg("pPlayer") ) );
        
        }
        { //::CMultiplayRules::FlPlayerSpawnTime
        
            typedef float ( ::CMultiplayRules::*FlPlayerSpawnTime_function_type )( ::CBasePlayer * ) ;
            typedef float ( CMultiplayRules_wrapper::*default_FlPlayerSpawnTime_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "FlPlayerSpawnTime"
                , FlPlayerSpawnTime_function_type(&::CMultiplayRules::FlPlayerSpawnTime)
                , default_FlPlayerSpawnTime_function_type(&CMultiplayRules_wrapper::default_FlPlayerSpawnTime)
                , ( bp::arg("pPlayer") ) );
        
        }
        { //::CMultiplayRules::FlWeaponRespawnTime
        
            typedef float ( ::CMultiplayRules::*FlWeaponRespawnTime_function_type )( ::CBaseCombatWeapon * ) ;
            typedef float ( CMultiplayRules_wrapper::*default_FlWeaponRespawnTime_function_type )( ::CBaseCombatWeapon * ) ;
            
            CMultiplayRules_exposer.def( 
                "FlWeaponRespawnTime"
                , FlWeaponRespawnTime_function_type(&::CMultiplayRules::FlWeaponRespawnTime)
                , default_FlWeaponRespawnTime_function_type(&CMultiplayRules_wrapper::default_FlWeaponRespawnTime)
                , ( bp::arg("pWeapon") ) );
        
        }
        { //::CMultiplayRules::FlWeaponTryRespawn
        
            typedef float ( ::CMultiplayRules::*FlWeaponTryRespawn_function_type )( ::CBaseCombatWeapon * ) ;
            typedef float ( CMultiplayRules_wrapper::*default_FlWeaponTryRespawn_function_type )( ::CBaseCombatWeapon * ) ;
            
            CMultiplayRules_exposer.def( 
                "FlWeaponTryRespawn"
                , FlWeaponTryRespawn_function_type(&::CMultiplayRules::FlWeaponTryRespawn)
                , default_FlWeaponTryRespawn_function_type(&CMultiplayRules_wrapper::default_FlWeaponTryRespawn)
                , ( bp::arg("pWeapon") ) );
        
        }
        { //::CMultiplayRules::FrameUpdatePostEntityThink
        
            typedef void ( ::CMultiplayRules::*FrameUpdatePostEntityThink_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_FrameUpdatePostEntityThink_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "FrameUpdatePostEntityThink"
                , FrameUpdatePostEntityThink_function_type(&::CMultiplayRules::FrameUpdatePostEntityThink)
                , default_FrameUpdatePostEntityThink_function_type(&CMultiplayRules_wrapper::default_FrameUpdatePostEntityThink) );
        
        }
        { //::CMultiplayRules::FreeMapCycleFileVector
        
            typedef void ( *FreeMapCycleFileVector_function_type )( ::CUtlVector< char*, CUtlMemory< char*, int > > & );
            
            CMultiplayRules_exposer.def( 
                "FreeMapCycleFileVector"
                , FreeMapCycleFileVector_function_type( &::CMultiplayRules::FreeMapCycleFileVector )
                , ( bp::arg("mapList") ) );
        
        }
        { //::CMultiplayRules::GetDeathScorer
        
            typedef ::CBasePlayer * ( ::CMultiplayRules::*GetDeathScorer_function_type )( ::CBaseEntity *,::CBaseEntity * ) ;
            
            CMultiplayRules_exposer.def( 
                "GetDeathScorer"
                , GetDeathScorer_function_type( &::CMultiplayRules::GetDeathScorer )
                , ( bp::arg("pKiller"), bp::arg("pInflictor") )
                , bp::return_value_policy< bp::return_by_value >() );
        
        }
        { //::CMultiplayRules::GetDeathScorer
        
            typedef ::CBasePlayer * ( ::CMultiplayRules::*GetDeathScorer_function_type )( ::CBaseEntity *,::CBaseEntity *,::CBaseEntity * ) ;
            typedef ::CBasePlayer * ( CMultiplayRules_wrapper::*default_GetDeathScorer_function_type )( ::CBaseEntity *,::CBaseEntity *,::CBaseEntity * ) ;
            
            CMultiplayRules_exposer.def( 
                "GetDeathScorer"
                , GetDeathScorer_function_type(&::CMultiplayRules::GetDeathScorer)
                , default_GetDeathScorer_function_type(&CMultiplayRules_wrapper::default_GetDeathScorer)
                , ( bp::arg("pKiller"), bp::arg("pInflictor"), bp::arg("pVictim") )
                , bp::return_value_policy< bp::return_by_value >() );
        
        }
        { //::CMultiplayRules::GetNextBestWeapon
        
            typedef ::CBaseCombatWeapon * ( ::CMultiplayRules::*GetNextBestWeapon_function_type )( ::CBaseCombatCharacter *,::CBaseCombatWeapon * ) ;
            typedef ::CBaseCombatWeapon * ( CMultiplayRules_wrapper::*default_GetNextBestWeapon_function_type )( ::CBaseCombatCharacter *,::CBaseCombatWeapon * ) ;
            
            CMultiplayRules_exposer.def( 
                "GetNextBestWeapon"
                , GetNextBestWeapon_function_type(&::CMultiplayRules::GetNextBestWeapon)
                , default_GetNextBestWeapon_function_type(&CMultiplayRules_wrapper::default_GetNextBestWeapon)
                , ( bp::arg("pPlayer"), bp::arg("pCurrentWeapon") )
                , bp::return_value_policy< bp::return_by_value >() );
        
        }
        { //::CMultiplayRules::GetNextLevelName
        
            typedef void ( ::CMultiplayRules::*GetNextLevelName_function_type )( char *,int,bool ) ;
            typedef void ( CMultiplayRules_wrapper::*default_GetNextLevelName_function_type )( char *,int,bool ) ;
            
            CMultiplayRules_exposer.def( 
                "GetNextLevelName"
                , GetNextLevelName_function_type(&::CMultiplayRules::GetNextLevelName)
                , default_GetNextLevelName_function_type(&CMultiplayRules_wrapper::default_GetNextLevelName)
                , ( bp::arg("szNextMap"), bp::arg("bufsize"), bp::arg("bRandom")=(bool)(false) ) );
        
        }
        { //::CMultiplayRules::GetPlayerSpawnSpot
        
            typedef ::CBaseEntity * ( ::CMultiplayRules::*GetPlayerSpawnSpot_function_type )( ::CBasePlayer * ) ;
            typedef ::CBaseEntity * ( CMultiplayRules_wrapper::*default_GetPlayerSpawnSpot_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "GetPlayerSpawnSpot"
                , GetPlayerSpawnSpot_function_type(&::CMultiplayRules::GetPlayerSpawnSpot)
                , default_GetPlayerSpawnSpot_function_type(&CMultiplayRules_wrapper::default_GetPlayerSpawnSpot)
                , ( bp::arg("pPlayer") )
                , bp::return_value_policy< bp::return_by_value >() );
        
        }
        { //::CMultiplayRules::GetTaggedConVarList
        
            typedef void ( ::CMultiplayRules::*GetTaggedConVarList_function_type )( ::KeyValues * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_GetTaggedConVarList_function_type )( ::KeyValues * ) ;
            
            CMultiplayRules_exposer.def( 
                "GetTaggedConVarList"
                , GetTaggedConVarList_function_type(&::CMultiplayRules::GetTaggedConVarList)
                , default_GetTaggedConVarList_function_type(&CMultiplayRules_wrapper::default_GetTaggedConVarList)
                , ( bp::arg("pCvarTagList") ) );
        
        }
        { //::CMultiplayRules::GetTeamID
        
            typedef char const * ( ::CMultiplayRules::*GetTeamID_function_type )( ::CBaseEntity * ) ;
            typedef char const * ( CMultiplayRules_wrapper::*default_GetTeamID_function_type )( ::CBaseEntity * ) ;
            
            CMultiplayRules_exposer.def( 
                "GetTeamID"
                , GetTeamID_function_type(&::CMultiplayRules::GetTeamID)
                , default_GetTeamID_function_type(&CMultiplayRules_wrapper::default_GetTeamID)
                , ( bp::arg("pEntity") ) );
        
        }
        { //::CMultiplayRules::HandleTimeLimitChange
        
            typedef void ( ::CMultiplayRules::*HandleTimeLimitChange_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_HandleTimeLimitChange_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "HandleTimeLimitChange"
                , HandleTimeLimitChange_function_type(&::CMultiplayRules::HandleTimeLimitChange)
                , default_HandleTimeLimitChange_function_type(&CMultiplayRules_wrapper::default_HandleTimeLimitChange) );
        
        }
        { //::CMultiplayRules::HaveAllPlayersSpeakConceptIfAllowed
        
            typedef void ( ::CMultiplayRules::*HaveAllPlayersSpeakConceptIfAllowed_function_type )( int,int,char const * ) ;
            
            CMultiplayRules_exposer.def( 
                "HaveAllPlayersSpeakConceptIfAllowed"
                , HaveAllPlayersSpeakConceptIfAllowed_function_type( &::CMultiplayRules::HaveAllPlayersSpeakConceptIfAllowed )
                , ( bp::arg("iConcept"), bp::arg("iTeam")=(int)(0), bp::arg("modifiers")=bp::object() ) );
        
        }
        { //::CMultiplayRules::IPointsForKill
        
            typedef int ( ::CMultiplayRules::*IPointsForKill_function_type )( ::CBasePlayer *,::CBasePlayer * ) ;
            typedef int ( CMultiplayRules_wrapper::*default_IPointsForKill_function_type )( ::CBasePlayer *,::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "IPointsForKill"
                , IPointsForKill_function_type(&::CMultiplayRules::IPointsForKill)
                , default_IPointsForKill_function_type(&CMultiplayRules_wrapper::default_IPointsForKill)
                , ( bp::arg("pAttacker"), bp::arg("pKilled") ) );
        
        }
        { //::CMultiplayRules::IncrementMapCycleIndex
        
            typedef void ( ::CMultiplayRules::*IncrementMapCycleIndex_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "IncrementMapCycleIndex"
                , IncrementMapCycleIndex_function_type( &::CMultiplayRules::IncrementMapCycleIndex ) );
        
        }
        { //::CMultiplayRules::Init
        
            typedef bool ( ::CMultiplayRules::*Init_function_type )(  ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_Init_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "Init"
                , Init_function_type(&::CMultiplayRules::Init)
                , default_Init_function_type(&CMultiplayRules_wrapper::default_Init) );
        
        }
        { //::CMultiplayRules::InitCustomResponseRulesDicts
        
            typedef void ( ::CMultiplayRules::*InitCustomResponseRulesDicts_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_InitCustomResponseRulesDicts_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "InitCustomResponseRulesDicts"
                , InitCustomResponseRulesDicts_function_type(&::CMultiplayRules::InitCustomResponseRulesDicts)
                , default_InitCustomResponseRulesDicts_function_type(&CMultiplayRules_wrapper::default_InitCustomResponseRulesDicts) );
        
        }
        { //::CMultiplayRules::InitHUD
        
            typedef void ( ::CMultiplayRules::*InitHUD_function_type )( ::CBasePlayer * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_InitHUD_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "InitHUD"
                , InitHUD_function_type(&::CMultiplayRules::InitHUD)
                , default_InitHUD_function_type(&CMultiplayRules_wrapper::default_InitHUD)
                , ( bp::arg("pl") ) );
        
        }
        { //::CMultiplayRules::IsAllowedToSpawn
        
            typedef bool ( ::CMultiplayRules::*IsAllowedToSpawn_function_type )( ::CBaseEntity * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_IsAllowedToSpawn_function_type )( ::CBaseEntity * ) ;
            
            CMultiplayRules_exposer.def( 
                "IsAllowedToSpawn"
                , IsAllowedToSpawn_function_type(&::CMultiplayRules::IsAllowedToSpawn)
                , default_IsAllowedToSpawn_function_type(&CMultiplayRules_wrapper::default_IsAllowedToSpawn)
                , ( bp::arg("pEntity") ) );
        
        }
        { //::CMultiplayRules::IsCoOp
        
            typedef bool ( ::CMultiplayRules::*IsCoOp_function_type )(  ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_IsCoOp_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "IsCoOp"
                , IsCoOp_function_type(&::CMultiplayRules::IsCoOp)
                , default_IsCoOp_function_type(&CMultiplayRules_wrapper::default_IsCoOp) );
        
        }
        { //::CMultiplayRules::IsDeathmatch
        
            typedef bool ( ::CMultiplayRules::*IsDeathmatch_function_type )(  ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_IsDeathmatch_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "IsDeathmatch"
                , IsDeathmatch_function_type(&::CMultiplayRules::IsDeathmatch)
                , default_IsDeathmatch_function_type(&CMultiplayRules_wrapper::default_IsDeathmatch) );
        
        }
        { //::CMultiplayRules::IsLoadingBugBaitReport
        
            typedef bool ( ::CMultiplayRules::*IsLoadingBugBaitReport_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "IsLoadingBugBaitReport"
                , IsLoadingBugBaitReport_function_type( &::CMultiplayRules::IsLoadingBugBaitReport ) );
        
        }
        { //::CMultiplayRules::IsMapInMapCycle
        
            typedef bool ( ::CMultiplayRules::*IsMapInMapCycle_function_type )( char const * ) ;
            
            CMultiplayRules_exposer.def( 
                "IsMapInMapCycle"
                , IsMapInMapCycle_function_type( &::CMultiplayRules::IsMapInMapCycle )
                , ( bp::arg("pszName") ) );
        
        }
        { //::CMultiplayRules::IsMultiplayer
        
            typedef bool ( ::CMultiplayRules::*IsMultiplayer_function_type )(  ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_IsMultiplayer_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "IsMultiplayer"
                , IsMultiplayer_function_type(&::CMultiplayRules::IsMultiplayer)
                , default_IsMultiplayer_function_type(&CMultiplayRules_wrapper::default_IsMultiplayer) );
        
        }
        { //::CMultiplayRules::ItemShouldRespawn
        
            typedef int ( ::CMultiplayRules::*ItemShouldRespawn_function_type )( ::CItem * ) ;
            typedef int ( CMultiplayRules_wrapper::*default_ItemShouldRespawn_function_type )( ::CItem * ) ;
            
            CMultiplayRules_exposer.def( 
                "ItemShouldRespawn"
                , ItemShouldRespawn_function_type(&::CMultiplayRules::ItemShouldRespawn)
                , default_ItemShouldRespawn_function_type(&CMultiplayRules_wrapper::default_ItemShouldRespawn)
                , ( bp::arg("pItem") ) );
        
        }
        { //::CMultiplayRules::LoadVoiceCommandScript
        
            typedef void ( ::CMultiplayRules::*LoadVoiceCommandScript_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "LoadVoiceCommandScript"
                , LoadVoiceCommandScript_function_type( &::CMultiplayRules::LoadVoiceCommandScript ) );
        
        }
        { //::CMultiplayRules::LoapMapCycleFileIntoVector
        
            typedef void ( *LoapMapCycleFileIntoVector_function_type )( char const *,::CUtlVector< char*, CUtlMemory< char*, int > > & );
            
            CMultiplayRules_exposer.def( 
                "LoapMapCycleFileIntoVector"
                , LoapMapCycleFileIntoVector_function_type( &::CMultiplayRules::LoapMapCycleFileIntoVector )
                , ( bp::arg("pszMapCycleFile"), bp::arg("mapList") ) );
        
        }
        { //::CMultiplayRules::PlayFootstepSounds
        
            typedef bool ( ::CMultiplayRules::*PlayFootstepSounds_function_type )( ::CBasePlayer * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_PlayFootstepSounds_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "PlayFootstepSounds"
                , PlayFootstepSounds_function_type(&::CMultiplayRules::PlayFootstepSounds)
                , default_PlayFootstepSounds_function_type(&CMultiplayRules_wrapper::default_PlayFootstepSounds)
                , ( bp::arg("pl") ) );
        
        }
        { //::CMultiplayRules::PlayTextureSounds
        
            typedef bool ( ::CMultiplayRules::*PlayTextureSounds_function_type )(  ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_PlayTextureSounds_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "PlayTextureSounds"
                , PlayTextureSounds_function_type(&::CMultiplayRules::PlayTextureSounds)
                , default_PlayTextureSounds_function_type(&CMultiplayRules_wrapper::default_PlayTextureSounds) );
        
        }
        { //::CMultiplayRules::PlayerCanHearChat
        
            typedef bool ( ::CMultiplayRules::*PlayerCanHearChat_function_type )( ::CBasePlayer *,::CBasePlayer * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_PlayerCanHearChat_function_type )( ::CBasePlayer *,::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "PlayerCanHearChat"
                , PlayerCanHearChat_function_type(&::CMultiplayRules::PlayerCanHearChat)
                , default_PlayerCanHearChat_function_type(&CMultiplayRules_wrapper::default_PlayerCanHearChat)
                , ( bp::arg("pListener"), bp::arg("pSpeaker") ) );
        
        }
        { //::CMultiplayRules::PlayerGotAmmo
        
            typedef void ( ::CMultiplayRules::*PlayerGotAmmo_function_type )( ::CBaseCombatCharacter *,char *,int ) ;
            typedef void ( CMultiplayRules_wrapper::*default_PlayerGotAmmo_function_type )( ::CBaseCombatCharacter *,char *,int ) ;
            
            CMultiplayRules_exposer.def( 
                "PlayerGotAmmo"
                , PlayerGotAmmo_function_type(&::CMultiplayRules::PlayerGotAmmo)
                , default_PlayerGotAmmo_function_type(&CMultiplayRules_wrapper::default_PlayerGotAmmo)
                , ( bp::arg("pPlayer"), bp::arg("szName"), bp::arg("iCount") ) );
        
        }
        { //::CMultiplayRules::PlayerGotItem
        
            typedef void ( ::CMultiplayRules::*PlayerGotItem_function_type )( ::CBasePlayer *,::CItem * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_PlayerGotItem_function_type )( ::CBasePlayer *,::CItem * ) ;
            
            CMultiplayRules_exposer.def( 
                "PlayerGotItem"
                , PlayerGotItem_function_type(&::CMultiplayRules::PlayerGotItem)
                , default_PlayerGotItem_function_type(&CMultiplayRules_wrapper::default_PlayerGotItem)
                , ( bp::arg("pPlayer"), bp::arg("pItem") ) );
        
        }
        { //::CMultiplayRules::PlayerKilled
        
            typedef void ( ::CMultiplayRules::*PlayerKilled_function_type )( ::CBasePlayer *,::CTakeDamageInfo const & ) ;
            typedef void ( CMultiplayRules_wrapper::*default_PlayerKilled_function_type )( ::CBasePlayer *,::CTakeDamageInfo const & ) ;
            
            CMultiplayRules_exposer.def( 
                "PlayerKilled"
                , PlayerKilled_function_type(&::CMultiplayRules::PlayerKilled)
                , default_PlayerKilled_function_type(&CMultiplayRules_wrapper::default_PlayerKilled)
                , ( bp::arg("pVictim"), bp::arg("info") ) );
        
        }
        { //::CMultiplayRules::PlayerRelationship
        
            typedef int ( ::CMultiplayRules::*PlayerRelationship_function_type )( ::CBaseEntity *,::CBaseEntity * ) ;
            typedef int ( CMultiplayRules_wrapper::*default_PlayerRelationship_function_type )( ::CBaseEntity *,::CBaseEntity * ) ;
            
            CMultiplayRules_exposer.def( 
                "PlayerRelationship"
                , PlayerRelationship_function_type(&::CMultiplayRules::PlayerRelationship)
                , default_PlayerRelationship_function_type(&CMultiplayRules_wrapper::default_PlayerRelationship)
                , ( bp::arg("pPlayer"), bp::arg("pTarget") ) );
        
        }
        { //::CMultiplayRules::PlayerSpawn
        
            typedef void ( ::CMultiplayRules::*PlayerSpawn_function_type )( ::CBasePlayer * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_PlayerSpawn_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "PlayerSpawn"
                , PlayerSpawn_function_type(&::CMultiplayRules::PlayerSpawn)
                , default_PlayerSpawn_function_type(&CMultiplayRules_wrapper::default_PlayerSpawn)
                , ( bp::arg("pPlayer") ) );
        
        }
        { //::CMultiplayRules::PlayerThink
        
            typedef void ( ::CMultiplayRules::*PlayerThink_function_type )( ::CBasePlayer * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_PlayerThink_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "PlayerThink"
                , PlayerThink_function_type(&::CMultiplayRules::PlayerThink)
                , default_PlayerThink_function_type(&CMultiplayRules_wrapper::default_PlayerThink)
                , ( bp::arg("pPlayer") ) );
        
        }
        { //::CMultiplayRules::RefreshSkillData
        
            typedef void ( ::CMultiplayRules::*RefreshSkillData_function_type )( bool ) ;
            typedef void ( CMultiplayRules_wrapper::*default_RefreshSkillData_function_type )( bool ) ;
            
            CMultiplayRules_exposer.def( 
                "RefreshSkillData"
                , RefreshSkillData_function_type(&::CMultiplayRules::RefreshSkillData)
                , default_RefreshSkillData_function_type(&CMultiplayRules_wrapper::default_RefreshSkillData)
                , ( bp::arg("forceUpdate") ) );
        
        }
        { //::CMultiplayRules::ResetMapCycleTimeStamp
        
            typedef void ( ::CMultiplayRules::*ResetMapCycleTimeStamp_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_ResetMapCycleTimeStamp_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "ResetMapCycleTimeStamp"
                , ResetMapCycleTimeStamp_function_type(&::CMultiplayRules::ResetMapCycleTimeStamp)
                , default_ResetMapCycleTimeStamp_function_type(&CMultiplayRules_wrapper::default_ResetMapCycleTimeStamp) );
        
        }
        { //::CMultiplayRules::ShouldDrawHeadLabels
        
            typedef bool ( ::CMultiplayRules::*ShouldDrawHeadLabels_function_type )(  ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_ShouldDrawHeadLabels_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "ShouldDrawHeadLabels"
                , ShouldDrawHeadLabels_function_type(&::CMultiplayRules::ShouldDrawHeadLabels)
                , default_ShouldDrawHeadLabels_function_type(&CMultiplayRules_wrapper::default_ShouldDrawHeadLabels) );
        
        }
        { //::CMultiplayRules::ShutdownCustomResponseRulesDicts
        
            typedef void ( ::CMultiplayRules::*ShutdownCustomResponseRulesDicts_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_ShutdownCustomResponseRulesDicts_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "ShutdownCustomResponseRulesDicts"
                , ShutdownCustomResponseRulesDicts_function_type(&::CMultiplayRules::ShutdownCustomResponseRulesDicts)
                , default_ShutdownCustomResponseRulesDicts_function_type(&CMultiplayRules_wrapper::default_ShutdownCustomResponseRulesDicts) );
        
        }
        { //::CMultiplayRules::SkipNextMapInCycle
        
            typedef void ( ::CMultiplayRules::*SkipNextMapInCycle_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "SkipNextMapInCycle"
                , SkipNextMapInCycle_function_type( &::CMultiplayRules::SkipNextMapInCycle ) );
        
        }
        { //::CMultiplayRules::SwitchToNextBestWeapon
        
            typedef bool ( ::CMultiplayRules::*SwitchToNextBestWeapon_function_type )( ::CBaseCombatCharacter *,::CBaseCombatWeapon * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_SwitchToNextBestWeapon_function_type )( ::CBaseCombatCharacter *,::CBaseCombatWeapon * ) ;
            
            CMultiplayRules_exposer.def( 
                "SwitchToNextBestWeapon"
                , SwitchToNextBestWeapon_function_type(&::CMultiplayRules::SwitchToNextBestWeapon)
                , default_SwitchToNextBestWeapon_function_type(&CMultiplayRules_wrapper::default_SwitchToNextBestWeapon)
                , ( bp::arg("pPlayer"), bp::arg("pCurrentWeapon") ) );
        
        }
        { //::CMultiplayRules::Think
        
            typedef void ( ::CMultiplayRules::*Think_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_Think_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "Think"
                , Think_function_type(&::CMultiplayRules::Think)
                , default_Think_function_type(&CMultiplayRules_wrapper::default_Think) );
        
        }
        { //::CMultiplayRules::VecItemRespawnAngles
        
            typedef ::QAngle ( ::CMultiplayRules::*VecItemRespawnAngles_function_type )( ::CItem * ) ;
            typedef ::QAngle ( CMultiplayRules_wrapper::*default_VecItemRespawnAngles_function_type )( ::CItem * ) ;
            
            CMultiplayRules_exposer.def( 
                "VecItemRespawnAngles"
                , VecItemRespawnAngles_function_type(&::CMultiplayRules::VecItemRespawnAngles)
                , default_VecItemRespawnAngles_function_type(&CMultiplayRules_wrapper::default_VecItemRespawnAngles)
                , ( bp::arg("pItem") ) );
        
        }
        { //::CMultiplayRules::VecItemRespawnSpot
        
            typedef ::Vector ( ::CMultiplayRules::*VecItemRespawnSpot_function_type )( ::CItem * ) ;
            typedef ::Vector ( CMultiplayRules_wrapper::*default_VecItemRespawnSpot_function_type )( ::CItem * ) ;
            
            CMultiplayRules_exposer.def( 
                "VecItemRespawnSpot"
                , VecItemRespawnSpot_function_type(&::CMultiplayRules::VecItemRespawnSpot)
                , default_VecItemRespawnSpot_function_type(&CMultiplayRules_wrapper::default_VecItemRespawnSpot)
                , ( bp::arg("pItem") ) );
        
        }
        { //::CMultiplayRules::VecWeaponRespawnSpot
        
            typedef ::Vector ( ::CMultiplayRules::*VecWeaponRespawnSpot_function_type )( ::CBaseCombatWeapon * ) ;
            typedef ::Vector ( CMultiplayRules_wrapper::*default_VecWeaponRespawnSpot_function_type )( ::CBaseCombatWeapon * ) ;
            
            CMultiplayRules_exposer.def( 
                "VecWeaponRespawnSpot"
                , VecWeaponRespawnSpot_function_type(&::CMultiplayRules::VecWeaponRespawnSpot)
                , default_VecWeaponRespawnSpot_function_type(&CMultiplayRules_wrapper::default_VecWeaponRespawnSpot)
                , ( bp::arg("pWeapon") ) );
        
        }
        { //::CMultiplayRules::WeaponShouldRespawn
        
            typedef int ( ::CMultiplayRules::*WeaponShouldRespawn_function_type )( ::CBaseCombatWeapon * ) ;
            typedef int ( CMultiplayRules_wrapper::*default_WeaponShouldRespawn_function_type )( ::CBaseCombatWeapon * ) ;
            
            CMultiplayRules_exposer.def( 
                "WeaponShouldRespawn"
                , WeaponShouldRespawn_function_type(&::CMultiplayRules::WeaponShouldRespawn)
                , default_WeaponShouldRespawn_function_type(&CMultiplayRules_wrapper::default_WeaponShouldRespawn)
                , ( bp::arg("pWeapon") ) );
        
        }
        CMultiplayRules_exposer.def_readwrite( "m_ResponseRules", &CMultiplayRules::m_ResponseRules );
        { //::CGameRules::AIClassText
        
            typedef char const * ( ::CGameRules::*AIClassText_function_type )( int ) ;
            typedef char const * ( CMultiplayRules_wrapper::*default_AIClassText_function_type )( int ) ;
            
            CMultiplayRules_exposer.def( 
                "AIClassText"
                , AIClassText_function_type(&::CGameRules::AIClassText)
                , default_AIClassText_function_type(&CMultiplayRules_wrapper::default_AIClassText)
                , ( bp::arg("classType") ) );
        
        }
        { //::CGameRules::AdjustPlayerDamageInflicted
        
            typedef float ( ::CGameRules::*AdjustPlayerDamageInflicted_function_type )( float ) ;
            typedef float ( CMultiplayRules_wrapper::*default_AdjustPlayerDamageInflicted_function_type )( float ) ;
            
            CMultiplayRules_exposer.def( 
                "AdjustPlayerDamageInflicted"
                , AdjustPlayerDamageInflicted_function_type(&::CGameRules::AdjustPlayerDamageInflicted)
                , default_AdjustPlayerDamageInflicted_function_type(&CMultiplayRules_wrapper::default_AdjustPlayerDamageInflicted)
                , ( bp::arg("damage") ) );
        
        }
        { //::CGameRules::AdjustPlayerDamageTaken
        
            typedef void ( ::CGameRules::*AdjustPlayerDamageTaken_function_type )( ::CTakeDamageInfo * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_AdjustPlayerDamageTaken_function_type )( ::CTakeDamageInfo * ) ;
            
            CMultiplayRules_exposer.def( 
                "AdjustPlayerDamageTaken"
                , AdjustPlayerDamageTaken_function_type(&::CGameRules::AdjustPlayerDamageTaken)
                , default_AdjustPlayerDamageTaken_function_type(&CMultiplayRules_wrapper::default_AdjustPlayerDamageTaken)
                , ( bp::arg("pInfo") ) );
        
        }
        { //::CGameRules::AllowThirdPersonCamera
        
            typedef bool ( ::CGameRules::*AllowThirdPersonCamera_function_type )(  ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_AllowThirdPersonCamera_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "AllowThirdPersonCamera"
                , AllowThirdPersonCamera_function_type(&::CGameRules::AllowThirdPersonCamera)
                , default_AllowThirdPersonCamera_function_type(&CMultiplayRules_wrapper::default_AllowThirdPersonCamera) );
        
        }
        { //::CGameRules::CanEntityBeUsePushed
        
            typedef bool ( ::CGameRules::*CanEntityBeUsePushed_function_type )( ::CBaseEntity * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_CanEntityBeUsePushed_function_type )( ::CBaseEntity * ) ;
            
            CMultiplayRules_exposer.def( 
                "CanEntityBeUsePushed"
                , CanEntityBeUsePushed_function_type(&::CGameRules::CanEntityBeUsePushed)
                , default_CanEntityBeUsePushed_function_type(&CMultiplayRules_wrapper::default_CanEntityBeUsePushed)
                , ( bp::arg("pEnt") ) );
        
        }
        { //::CGameRules::CanHaveAmmo
        
            typedef bool ( ::CGameRules::*CanHaveAmmo_function_type )( ::CBaseCombatCharacter *,int ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_CanHaveAmmo_function_type )( ::CBaseCombatCharacter *,int ) ;
            
            CMultiplayRules_exposer.def( 
                "CanHaveAmmo"
                , CanHaveAmmo_function_type(&::CGameRules::CanHaveAmmo)
                , default_CanHaveAmmo_function_type(&CMultiplayRules_wrapper::default_CanHaveAmmo)
                , ( bp::arg("pPlayer"), bp::arg("iAmmoIndex") ) );
        
        }
        { //::CGameRules::CanHaveAmmo
        
            typedef bool ( ::CGameRules::*CanHaveAmmo_function_type )( ::CBaseCombatCharacter *,char const * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_CanHaveAmmo_function_type )( ::CBaseCombatCharacter *,char const * ) ;
            
            CMultiplayRules_exposer.def( 
                "CanHaveAmmo"
                , CanHaveAmmo_function_type(&::CGameRules::CanHaveAmmo)
                , default_CanHaveAmmo_function_type(&CMultiplayRules_wrapper::default_CanHaveAmmo)
                , ( bp::arg("pPlayer"), bp::arg("szName") ) );
        
        }
        { //::CGameRules::ChangePlayerTeam
        
            typedef void ( ::CGameRules::*ChangePlayerTeam_function_type )( ::CBasePlayer *,char const *,bool,bool ) ;
            typedef void ( CMultiplayRules_wrapper::*default_ChangePlayerTeam_function_type )( ::CBasePlayer *,char const *,bool,bool ) ;
            
            CMultiplayRules_exposer.def( 
                "ChangePlayerTeam"
                , ChangePlayerTeam_function_type(&::CGameRules::ChangePlayerTeam)
                , default_ChangePlayerTeam_function_type(&CMultiplayRules_wrapper::default_ChangePlayerTeam)
                , ( bp::arg("pPlayer"), bp::arg("pTeamName"), bp::arg("bKill"), bp::arg("bGib") ) );
        
        }
        { //::CGameRules::CheckChatText
        
            typedef void ( ::CGameRules::*CheckChatText_function_type )( ::CBasePlayer *,char * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_CheckChatText_function_type )( ::CBasePlayer *,char * ) ;
            
            CMultiplayRules_exposer.def( 
                "CheckChatText"
                , CheckChatText_function_type(&::CGameRules::CheckChatText)
                , default_CheckChatText_function_type(&CMultiplayRules_wrapper::default_CheckChatText)
                , ( bp::arg("pPlayer"), bp::arg("pText") ) );
        
        }
        { //::CGameRules::CheckHaptics
        
            typedef void ( ::CGameRules::*CheckHaptics_function_type )( ::CBasePlayer * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_CheckHaptics_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "CheckHaptics"
                , CheckHaptics_function_type(&::CGameRules::CheckHaptics)
                , default_CheckHaptics_function_type(&CMultiplayRules_wrapper::default_CheckHaptics)
                , ( bp::arg("pPlayer") ) );
        
        }
        { //::CGameRules::ClientSpawned
        
            typedef void ( ::CGameRules::*ClientSpawned_function_type )( ::edict_t * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_ClientSpawned_function_type )( ::edict_t * ) ;
            
            CMultiplayRules_exposer.def( 
                "ClientSpawned"
                , ClientSpawned_function_type(&::CGameRules::ClientSpawned)
                , default_ClientSpawned_function_type(&CMultiplayRules_wrapper::default_ClientSpawned)
                , ( bp::arg("pPlayer") ) );
        
        }
        { //::CGameRules::CreateCustomNetworkStringTables
        
            typedef void ( ::CGameRules::*CreateCustomNetworkStringTables_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_CreateCustomNetworkStringTables_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "CreateCustomNetworkStringTables"
                , CreateCustomNetworkStringTables_function_type(&::CGameRules::CreateCustomNetworkStringTables)
                , default_CreateCustomNetworkStringTables_function_type(&CMultiplayRules_wrapper::default_CreateCustomNetworkStringTables) );
        
        }
        { //::CGameRules::CreateStandardEntities
        
            typedef void ( ::CGameRules::*CreateStandardEntities_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_CreateStandardEntities_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "CreateStandardEntities"
                , CreateStandardEntities_function_type(&::CGameRules::CreateStandardEntities)
                , default_CreateStandardEntities_function_type(&CMultiplayRules_wrapper::default_CreateStandardEntities) );
        
        }
        { //::CGameRules::DefaultFOV
        
            typedef int ( ::CGameRules::*DefaultFOV_function_type )(  ) ;
            typedef int ( CMultiplayRules_wrapper::*default_DefaultFOV_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "DefaultFOV"
                , DefaultFOV_function_type(&::CGameRules::DefaultFOV)
                , default_DefaultFOV_function_type(&CMultiplayRules_wrapper::default_DefaultFOV) );
        
        }
        { //::CGameRules::EndGameFrame
        
            typedef void ( ::CGameRules::*EndGameFrame_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_EndGameFrame_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "EndGameFrame"
                , EndGameFrame_function_type(&::CGameRules::EndGameFrame)
                , default_EndGameFrame_function_type(&CMultiplayRules_wrapper::default_EndGameFrame) );
        
        }
        { //::CGameRules::FlPlayerFallDeathDoesScreenFade
        
            typedef bool ( ::CGameRules::*FlPlayerFallDeathDoesScreenFade_function_type )( ::CBasePlayer * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_FlPlayerFallDeathDoesScreenFade_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "FlPlayerFallDeathDoesScreenFade"
                , FlPlayerFallDeathDoesScreenFade_function_type(&::CGameRules::FlPlayerFallDeathDoesScreenFade)
                , default_FlPlayerFallDeathDoesScreenFade_function_type(&CMultiplayRules_wrapper::default_FlPlayerFallDeathDoesScreenFade)
                , ( bp::arg("pl") ) );
        
        }
        { //::CGameRules::GetAmmoQuantityScale
        
            typedef float ( ::CGameRules::*GetAmmoQuantityScale_function_type )( int ) ;
            typedef float ( CMultiplayRules_wrapper::*default_GetAmmoQuantityScale_function_type )( int ) ;
            
            CMultiplayRules_exposer.def( 
                "GetAmmoQuantityScale"
                , GetAmmoQuantityScale_function_type(&::CGameRules::GetAmmoQuantityScale)
                , default_GetAmmoQuantityScale_function_type(&CMultiplayRules_wrapper::default_GetAmmoQuantityScale)
                , ( bp::arg("iAmmoIndex") ) );
        
        }
        { //::CGameRules::GetAutoAimMode
        
            typedef int ( ::CGameRules::*GetAutoAimMode_function_type )(  ) ;
            typedef int ( CMultiplayRules_wrapper::*default_GetAutoAimMode_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "GetAutoAimMode"
                , GetAutoAimMode_function_type(&::CGameRules::GetAutoAimMode)
                , default_GetAutoAimMode_function_type(&CMultiplayRules_wrapper::default_GetAutoAimMode) );
        
        }
        { //::CGameRules::GetAutoAimScale
        
            typedef float ( ::CGameRules::*GetAutoAimScale_function_type )( ::CBasePlayer * ) ;
            typedef float ( CMultiplayRules_wrapper::*default_GetAutoAimScale_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "GetAutoAimScale"
                , GetAutoAimScale_function_type(&::CGameRules::GetAutoAimScale)
                , default_GetAutoAimScale_function_type(&CMultiplayRules_wrapper::default_GetAutoAimScale)
                , ( bp::arg("pPlayer") ) );
        
        }
        { //::CGameRules::GetChatFormat
        
            typedef char const * ( ::CGameRules::*GetChatFormat_function_type )( bool,::CBasePlayer * ) ;
            typedef char const * ( CMultiplayRules_wrapper::*default_GetChatFormat_function_type )( bool,::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "GetChatFormat"
                , GetChatFormat_function_type(&::CGameRules::GetChatFormat)
                , default_GetChatFormat_function_type(&CMultiplayRules_wrapper::default_GetChatFormat)
                , ( bp::arg("bTeamOnly"), bp::arg("pPlayer") ) );
        
        }
        { //::CGameRules::GetChatLocation
        
            typedef char const * ( ::CGameRules::*GetChatLocation_function_type )( bool,::CBasePlayer * ) ;
            typedef char const * ( CMultiplayRules_wrapper::*default_GetChatLocation_function_type )( bool,::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "GetChatLocation"
                , GetChatLocation_function_type(&::CGameRules::GetChatLocation)
                , default_GetChatLocation_function_type(&CMultiplayRules_wrapper::default_GetChatLocation)
                , ( bp::arg("bTeamOnly"), bp::arg("pPlayer") ) );
        
        }
        { //::CGameRules::GetChatPrefix
        
            typedef char const * ( ::CGameRules::*GetChatPrefix_function_type )( bool,::CBasePlayer * ) ;
            typedef char const * ( CMultiplayRules_wrapper::*default_GetChatPrefix_function_type )( bool,::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "GetChatPrefix"
                , GetChatPrefix_function_type(&::CGameRules::GetChatPrefix)
                , default_GetChatPrefix_function_type(&CMultiplayRules_wrapper::default_GetChatPrefix)
                , ( bp::arg("bTeamOnly"), bp::arg("pPlayer") ) );
        
        }
        { //::CGameRules::GetDamageCustomString
        
            typedef char const * ( ::CGameRules::*GetDamageCustomString_function_type )( ::CTakeDamageInfo const & ) ;
            typedef char const * ( CMultiplayRules_wrapper::*default_GetDamageCustomString_function_type )( ::CTakeDamageInfo const & ) ;
            
            CMultiplayRules_exposer.def( 
                "GetDamageCustomString"
                , GetDamageCustomString_function_type(&::CGameRules::GetDamageCustomString)
                , default_GetDamageCustomString_function_type(&CMultiplayRules_wrapper::default_GetDamageCustomString)
                , ( bp::arg("info") ) );
        
        }
        { //::CGameRules::GetDamageMultiplier
        
            typedef float ( ::CGameRules::*GetDamageMultiplier_function_type )(  ) ;
            typedef float ( CMultiplayRules_wrapper::*default_GetDamageMultiplier_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "GetDamageMultiplier"
                , GetDamageMultiplier_function_type(&::CGameRules::GetDamageMultiplier)
                , default_GetDamageMultiplier_function_type(&CMultiplayRules_wrapper::default_GetDamageMultiplier) );
        
        }
        { //::CGameRules::GetGameDescription
        
            typedef char const * ( ::CGameRules::*GetGameDescription_function_type )(  ) ;
            typedef char const * ( CMultiplayRules_wrapper::*default_GetGameDescription_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "GetGameDescription"
                , GetGameDescription_function_type(&::CGameRules::GetGameDescription)
                , default_GetGameDescription_function_type(&CMultiplayRules_wrapper::default_GetGameDescription) );
        
        }
        { //::CGameRules::GetGameType
        
            typedef int ( ::CGameRules::*GetGameType_function_type )(  ) ;
            typedef int ( CMultiplayRules_wrapper::*default_GetGameType_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "GetGameType"
                , GetGameType_function_type(&::CGameRules::GetGameType)
                , default_GetGameType_function_type(&CMultiplayRules_wrapper::default_GetGameType) );
        
        }
        { //::CGameRules::GetGameTypeName
        
            typedef char const * ( ::CGameRules::*GetGameTypeName_function_type )(  ) ;
            typedef char const * ( CMultiplayRules_wrapper::*default_GetGameTypeName_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "GetGameTypeName"
                , GetGameTypeName_function_type(&::CGameRules::GetGameTypeName)
                , default_GetGameTypeName_function_type(&CMultiplayRules_wrapper::default_GetGameTypeName) );
        
        }
        { //::CGameRules::GetIndexedTeamName
        
            typedef char const * ( ::CGameRules::*GetIndexedTeamName_function_type )( int ) ;
            typedef char const * ( CMultiplayRules_wrapper::*default_GetIndexedTeamName_function_type )( int ) ;
            
            CMultiplayRules_exposer.def( 
                "GetIndexedTeamName"
                , GetIndexedTeamName_function_type(&::CGameRules::GetIndexedTeamName)
                , default_GetIndexedTeamName_function_type(&CMultiplayRules_wrapper::default_GetIndexedTeamName)
                , ( bp::arg("teamIndex") ) );
        
        }
        { //::CGameRules::GetSkillLevel
        
            typedef int ( ::CGameRules::*GetSkillLevel_function_type )(  ) ;
            typedef int ( CMultiplayRules_wrapper::*default_GetSkillLevel_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "GetSkillLevel"
                , GetSkillLevel_function_type(&::CGameRules::GetSkillLevel)
                , default_GetSkillLevel_function_type(&CMultiplayRules_wrapper::default_GetSkillLevel) );
        
        }
        { //::CGameRules::GetTeamIndex
        
            typedef int ( ::CGameRules::*GetTeamIndex_function_type )( char const * ) ;
            typedef int ( CMultiplayRules_wrapper::*default_GetTeamIndex_function_type )( char const * ) ;
            
            CMultiplayRules_exposer.def( 
                "GetTeamIndex"
                , GetTeamIndex_function_type(&::CGameRules::GetTeamIndex)
                , default_GetTeamIndex_function_type(&CMultiplayRules_wrapper::default_GetTeamIndex)
                , ( bp::arg("pTeamName") ) );
        
        }
        { //::CGameRules::InRoundRestart
        
            typedef bool ( ::CGameRules::*InRoundRestart_function_type )(  ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_InRoundRestart_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "InRoundRestart"
                , InRoundRestart_function_type(&::CGameRules::InRoundRestart)
                , default_InRoundRestart_function_type(&CMultiplayRules_wrapper::default_InRoundRestart) );
        
        }
        { //::CGameRules::InitDefaultAIRelationships
        
            typedef void ( ::CGameRules::*InitDefaultAIRelationships_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_InitDefaultAIRelationships_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "InitDefaultAIRelationships"
                , InitDefaultAIRelationships_function_type(&::CGameRules::InitDefaultAIRelationships)
                , default_InitDefaultAIRelationships_function_type(&CMultiplayRules_wrapper::default_InitDefaultAIRelationships) );
        
        }
        { //::CGameRules::InitGamerules
        
            typedef void ( ::CGameRules::*InitGamerules_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_InitGamerules_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "InitGamerules"
                , InitGamerules_function_type(&::CGameRules::InitGamerules)
                , default_InitGamerules_function_type(&CMultiplayRules_wrapper::default_InitGamerules) );
        
        }
        { //::CGameRules::IsConnectedUserInfoChangeAllowed
        
            typedef bool ( ::CGameRules::*IsConnectedUserInfoChangeAllowed_function_type )( ::CBasePlayer * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_IsConnectedUserInfoChangeAllowed_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "IsConnectedUserInfoChangeAllowed"
                , IsConnectedUserInfoChangeAllowed_function_type(&::CGameRules::IsConnectedUserInfoChangeAllowed)
                , default_IsConnectedUserInfoChangeAllowed_function_type(&CMultiplayRules_wrapper::default_IsConnectedUserInfoChangeAllowed)
                , ( bp::arg("pPlayer") ) );
        
        }
        { //::CGameRules::IsHolidayActive
        
            typedef bool ( ::CGameRules::*IsHolidayActive_function_type )( int ) const;
            typedef bool ( CMultiplayRules_wrapper::*default_IsHolidayActive_function_type )( int ) const;
            
            CMultiplayRules_exposer.def( 
                "IsHolidayActive"
                , IsHolidayActive_function_type(&::CGameRules::IsHolidayActive)
                , default_IsHolidayActive_function_type(&CMultiplayRules_wrapper::default_IsHolidayActive)
                , ( bp::arg("eHoliday") ) );
        
        }
        { //::CGameRules::IsSkillLevel
        
            typedef bool ( ::CGameRules::*IsSkillLevel_function_type )( int ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_IsSkillLevel_function_type )( int ) ;
            
            CMultiplayRules_exposer.def( 
                "IsSkillLevel"
                , IsSkillLevel_function_type(&::CGameRules::IsSkillLevel)
                , default_IsSkillLevel_function_type(&CMultiplayRules_wrapper::default_IsSkillLevel)
                , ( bp::arg("iLevel") ) );
        
        }
        { //::CGameRules::IsSpawnPointValid
        
            typedef bool ( ::CGameRules::*IsSpawnPointValid_function_type )( ::CBaseEntity *,::CBasePlayer * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_IsSpawnPointValid_function_type )( ::CBaseEntity *,::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "IsSpawnPointValid"
                , IsSpawnPointValid_function_type(&::CGameRules::IsSpawnPointValid)
                , default_IsSpawnPointValid_function_type(&CMultiplayRules_wrapper::default_IsSpawnPointValid)
                , ( bp::arg("pSpot"), bp::arg("pPlayer") ) );
        
        }
        { //::CGameRules::IsTeamplay
        
            typedef bool ( ::CGameRules::*IsTeamplay_function_type )(  ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_IsTeamplay_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "IsTeamplay"
                , IsTeamplay_function_type(&::CGameRules::IsTeamplay)
                , default_IsTeamplay_function_type(&CMultiplayRules_wrapper::default_IsTeamplay) );
        
        }
        { //::CGameRules::IsValidTeam
        
            typedef bool ( ::CGameRules::*IsValidTeam_function_type )( char const * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_IsValidTeam_function_type )( char const * ) ;
            
            CMultiplayRules_exposer.def( 
                "IsValidTeam"
                , IsValidTeam_function_type(&::CGameRules::IsValidTeam)
                , default_IsValidTeam_function_type(&CMultiplayRules_wrapper::default_IsValidTeam)
                , ( bp::arg("pTeamName") ) );
        
        }
        { //::CGameRules::LevelShutdown
        
            typedef void ( ::CGameRules::*LevelShutdown_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_LevelShutdown_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "LevelShutdown"
                , LevelShutdown_function_type(&::CGameRules::LevelShutdown)
                , default_LevelShutdown_function_type(&CMultiplayRules_wrapper::default_LevelShutdown) );
        
        }
        { //::CGameRules::MarkAchievement
        
            typedef void ( ::CGameRules::*MarkAchievement_function_type )( ::IRecipientFilter &,char const * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_MarkAchievement_function_type )( ::IRecipientFilter &,char const * ) ;
            
            CMultiplayRules_exposer.def( 
                "MarkAchievement"
                , MarkAchievement_function_type(&::CGameRules::MarkAchievement)
                , default_MarkAchievement_function_type(&CMultiplayRules_wrapper::default_MarkAchievement)
                , ( bp::arg("filter"), bp::arg("pchAchievementName") ) );
        
        }
        { //::CGameRules::Name
        
            typedef char const * ( ::CGameRules::*Name_function_type )(  ) ;
            typedef char const * ( CMultiplayRules_wrapper::*default_Name_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "Name"
                , Name_function_type(&::CGameRules::Name)
                , default_Name_function_type(&CMultiplayRules_wrapper::default_Name) );
        
        }
        { //::CGameRules::OnFileReceived
        
            typedef void ( ::CGameRules::*OnFileReceived_function_type )( char const *,unsigned int ) ;
            typedef void ( CMultiplayRules_wrapper::*default_OnFileReceived_function_type )( char const *,unsigned int ) ;
            
            CMultiplayRules_exposer.def( 
                "OnFileReceived"
                , OnFileReceived_function_type(&::CGameRules::OnFileReceived)
                , default_OnFileReceived_function_type(&CMultiplayRules_wrapper::default_OnFileReceived)
                , ( bp::arg("fileName"), bp::arg("transferID") ) );
        
        }
        { //::CGameRules::OnNavMeshLoad
        
            typedef void ( ::CGameRules::*OnNavMeshLoad_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_OnNavMeshLoad_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "OnNavMeshLoad"
                , OnNavMeshLoad_function_type(&::CGameRules::OnNavMeshLoad)
                , default_OnNavMeshLoad_function_type(&CMultiplayRules_wrapper::default_OnNavMeshLoad) );
        
        }
        { //::CGameRules::OnSkillLevelChanged
        
            typedef void ( ::CGameRules::*OnSkillLevelChanged_function_type )( int ) ;
            typedef void ( CMultiplayRules_wrapper::*default_OnSkillLevelChanged_function_type )( int ) ;
            
            CMultiplayRules_exposer.def( 
                "OnSkillLevelChanged"
                , OnSkillLevelChanged_function_type(&::CGameRules::OnSkillLevelChanged)
                , default_OnSkillLevelChanged_function_type(&CMultiplayRules_wrapper::default_OnSkillLevelChanged)
                , ( bp::arg("iNewLevel") ) );
        
        }
        { //::CGameRules::Precache
        
            typedef void ( ::CGameRules::*Precache_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_Precache_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "Precache"
                , Precache_function_type(&::CGameRules::Precache)
                , default_Precache_function_type(&CMultiplayRules_wrapper::default_Precache) );
        
        }
        { //::CGameRules::ProcessVerboseLogOutput
        
            typedef void ( ::CGameRules::*ProcessVerboseLogOutput_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_ProcessVerboseLogOutput_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "ProcessVerboseLogOutput"
                , ProcessVerboseLogOutput_function_type(&::CGameRules::ProcessVerboseLogOutput)
                , default_ProcessVerboseLogOutput_function_type(&CMultiplayRules_wrapper::default_ProcessVerboseLogOutput) );
        
        }
        { //::CGameRules::RadiusDamage
        
            typedef void ( ::CGameRules::*RadiusDamage_function_type )( ::CTakeDamageInfo const &,::Vector const &,float,int,::CBaseEntity * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_RadiusDamage_function_type )( ::CTakeDamageInfo const &,::Vector const &,float,int,::CBaseEntity * ) ;
            
            CMultiplayRules_exposer.def( 
                "RadiusDamage"
                , RadiusDamage_function_type(&::CGameRules::RadiusDamage)
                , default_RadiusDamage_function_type(&CMultiplayRules_wrapper::default_RadiusDamage)
                , ( bp::arg("info"), bp::arg("vecSrc"), bp::arg("flRadius"), bp::arg("iClassIgnore"), bp::arg("pEntityIgnore") ) );
        
        }
        { //::CGameRules::SetDefaultPlayerTeam
        
            typedef char const * ( ::CGameRules::*SetDefaultPlayerTeam_function_type )( ::CBasePlayer * ) ;
            typedef char const * ( CMultiplayRules_wrapper::*default_SetDefaultPlayerTeam_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "SetDefaultPlayerTeam"
                , SetDefaultPlayerTeam_function_type(&::CGameRules::SetDefaultPlayerTeam)
                , default_SetDefaultPlayerTeam_function_type(&CMultiplayRules_wrapper::default_SetDefaultPlayerTeam)
                , ( bp::arg("pPlayer") ) );
        
        }
        { //::CGameRules::SetSkillLevel
        
            typedef void ( ::CGameRules::*SetSkillLevel_function_type )( int ) ;
            typedef void ( CMultiplayRules_wrapper::*default_SetSkillLevel_function_type )( int ) ;
            
            CMultiplayRules_exposer.def( 
                "SetSkillLevel"
                , SetSkillLevel_function_type(&::CGameRules::SetSkillLevel)
                , default_SetSkillLevel_function_type(&CMultiplayRules_wrapper::default_SetSkillLevel)
                , ( bp::arg("iLevel") ) );
        
        }
        { //::CGameRules::ShouldAutoAim
        
            typedef bool ( ::CGameRules::*ShouldAutoAim_function_type )( ::CBasePlayer *,::edict_t * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_ShouldAutoAim_function_type )( ::CBasePlayer *,::edict_t * ) ;
            
            CMultiplayRules_exposer.def( 
                "ShouldAutoAim"
                , ShouldAutoAim_function_type(&::CGameRules::ShouldAutoAim)
                , default_ShouldAutoAim_function_type(&CMultiplayRules_wrapper::default_ShouldAutoAim)
                , ( bp::arg("pPlayer"), bp::arg("target") ) );
        
        }
        { //::CGameRules::ShouldBurningPropsEmitLight
        
            typedef bool ( ::CGameRules::*ShouldBurningPropsEmitLight_function_type )(  ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_ShouldBurningPropsEmitLight_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "ShouldBurningPropsEmitLight"
                , ShouldBurningPropsEmitLight_function_type(&::CGameRules::ShouldBurningPropsEmitLight)
                , default_ShouldBurningPropsEmitLight_function_type(&CMultiplayRules_wrapper::default_ShouldBurningPropsEmitLight) );
        
        }
        { //::CGameRules::ShouldUseRobustRadiusDamage
        
            typedef bool ( ::CGameRules::*ShouldUseRobustRadiusDamage_function_type )( ::CBaseEntity * ) ;
            typedef bool ( CMultiplayRules_wrapper::*default_ShouldUseRobustRadiusDamage_function_type )( ::CBaseEntity * ) ;
            
            CMultiplayRules_exposer.def( 
                "ShouldUseRobustRadiusDamage"
                , ShouldUseRobustRadiusDamage_function_type(&::CGameRules::ShouldUseRobustRadiusDamage)
                , default_ShouldUseRobustRadiusDamage_function_type(&CMultiplayRules_wrapper::default_ShouldUseRobustRadiusDamage)
                , ( bp::arg("pEntity") ) );
        
        }
        { //::CGameRules::ShutdownGamerules
        
            typedef void ( ::CGameRules::*ShutdownGamerules_function_type )(  ) ;
            typedef void ( CMultiplayRules_wrapper::*default_ShutdownGamerules_function_type )(  ) ;
            
            CMultiplayRules_exposer.def( 
                "ShutdownGamerules"
                , ShutdownGamerules_function_type(&::CGameRules::ShutdownGamerules)
                , default_ShutdownGamerules_function_type(&CMultiplayRules_wrapper::default_ShutdownGamerules) );
        
        }
        { //::CGameRules::UpdateClientData
        
            typedef void ( ::CGameRules::*UpdateClientData_function_type )( ::CBasePlayer * ) ;
            typedef void ( CMultiplayRules_wrapper::*default_UpdateClientData_function_type )( ::CBasePlayer * ) ;
            
            CMultiplayRules_exposer.def( 
                "UpdateClientData"
                , UpdateClientData_function_type(&::CGameRules::UpdateClientData)
                , default_UpdateClientData_function_type(&CMultiplayRules_wrapper::default_UpdateClientData)
                , ( bp::arg("pPlayer") ) );
        
        }
        { //::CGameRules::WeaponTraceEntity
        
            typedef float ( ::CGameRules::*WeaponTraceEntity_function_type )( ::CBaseEntity *,::Vector const &,::Vector const &,unsigned int,::trace_t * ) ;
            typedef float ( CMultiplayRules_wrapper::*default_WeaponTraceEntity_function_type )( ::CBaseEntity *,::Vector const &,::Vector const &,unsigned int,::trace_t * ) ;
            
            CMultiplayRules_exposer.def( 
                "WeaponTraceEntity"
                , WeaponTraceEntity_function_type(&::CGameRules::WeaponTraceEntity)
                , default_WeaponTraceEntity_function_type(&CMultiplayRules_wrapper::default_WeaponTraceEntity)
                , ( bp::arg("pEntity"), bp::arg("vecStart"), bp::arg("vecEnd"), bp::arg("mask"), bp::arg("ptr") ) );
        
        }
        CMultiplayRules_exposer.staticmethod( "DetermineMapCycleFilename" );
        CMultiplayRules_exposer.staticmethod( "FreeMapCycleFileVector" );
        CMultiplayRules_exposer.staticmethod( "LoapMapCycleFileIntoVector" );
    }

}

