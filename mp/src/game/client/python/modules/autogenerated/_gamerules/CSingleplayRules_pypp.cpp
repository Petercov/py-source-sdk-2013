// This file has been generated by Py++.

#include "cbase.h"
// This file has been generated by Py++.

#include "cbase.h"
#include "gamerules.h"
#include "multiplay_gamerules.h"
#include "singleplay_gamerules.h"
#include "teamplay_gamerules.h"
#include "srcpy_gamerules.h"
#include "hl2mp/hl2mp_gamerules.h"
#include "ammodef.h"
#include "takedamageinfo.h"
#include "tier0/valve_minmax_off.h"
#include "srcpy.h"
#include "tier0/valve_minmax_on.h"
#include "tier0/memdbgon.h"
#include "CSingleplayRules_pypp.hpp"

namespace bp = boost::python;

struct C_SingleplayRules_wrapper : C_SingleplayRules, bp::wrapper< C_SingleplayRules > {

    C_SingleplayRules_wrapper(C_SingleplayRules const & arg )
    : C_SingleplayRules( arg )
      , bp::wrapper< C_SingleplayRules >(){
        // copy constructor
        
    }

    C_SingleplayRules_wrapper()
    : C_SingleplayRules()
      , bp::wrapper< C_SingleplayRules >(){
        // null constructor
        
    }

    virtual int Damage_GetNoPhysicsForce(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetNoPhysicsForce: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetNoPhysicsForce(  ) of Class: C_SingleplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetNoPhysicsForce = this->get_override( "Damage_GetNoPhysicsForce" );
        if( func_Damage_GetNoPhysicsForce.ptr() != Py_None )
            try {
                return func_Damage_GetNoPhysicsForce(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_SingleplayRules::Damage_GetNoPhysicsForce(  );
            }
        else
            return this->C_SingleplayRules::Damage_GetNoPhysicsForce(  );
    }
    
    int default_Damage_GetNoPhysicsForce(  ) {
        return C_SingleplayRules::Damage_GetNoPhysicsForce( );
    }

    virtual int Damage_GetShouldGibCorpse(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetShouldGibCorpse: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetShouldGibCorpse(  ) of Class: C_SingleplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetShouldGibCorpse = this->get_override( "Damage_GetShouldGibCorpse" );
        if( func_Damage_GetShouldGibCorpse.ptr() != Py_None )
            try {
                return func_Damage_GetShouldGibCorpse(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_SingleplayRules::Damage_GetShouldGibCorpse(  );
            }
        else
            return this->C_SingleplayRules::Damage_GetShouldGibCorpse(  );
    }
    
    int default_Damage_GetShouldGibCorpse(  ) {
        return C_SingleplayRules::Damage_GetShouldGibCorpse( );
    }

    virtual int Damage_GetShouldNotBleed(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetShouldNotBleed: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetShouldNotBleed(  ) of Class: C_SingleplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetShouldNotBleed = this->get_override( "Damage_GetShouldNotBleed" );
        if( func_Damage_GetShouldNotBleed.ptr() != Py_None )
            try {
                return func_Damage_GetShouldNotBleed(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_SingleplayRules::Damage_GetShouldNotBleed(  );
            }
        else
            return this->C_SingleplayRules::Damage_GetShouldNotBleed(  );
    }
    
    int default_Damage_GetShouldNotBleed(  ) {
        return C_SingleplayRules::Damage_GetShouldNotBleed( );
    }

    virtual int Damage_GetShowOnHud(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetShowOnHud: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetShowOnHud(  ) of Class: C_SingleplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetShowOnHud = this->get_override( "Damage_GetShowOnHud" );
        if( func_Damage_GetShowOnHud.ptr() != Py_None )
            try {
                return func_Damage_GetShowOnHud(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_SingleplayRules::Damage_GetShowOnHud(  );
            }
        else
            return this->C_SingleplayRules::Damage_GetShowOnHud(  );
    }
    
    int default_Damage_GetShowOnHud(  ) {
        return C_SingleplayRules::Damage_GetShowOnHud( );
    }

    virtual int Damage_GetTimeBased(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetTimeBased: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetTimeBased(  ) of Class: C_SingleplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetTimeBased = this->get_override( "Damage_GetTimeBased" );
        if( func_Damage_GetTimeBased.ptr() != Py_None )
            try {
                return func_Damage_GetTimeBased(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_SingleplayRules::Damage_GetTimeBased(  );
            }
        else
            return this->C_SingleplayRules::Damage_GetTimeBased(  );
    }
    
    int default_Damage_GetTimeBased(  ) {
        return C_SingleplayRules::Damage_GetTimeBased( );
    }

    virtual bool Damage_IsTimeBased( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_IsTimeBased: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_IsTimeBased( iDmgType ) of Class: C_SingleplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_IsTimeBased = this->get_override( "Damage_IsTimeBased" );
        if( func_Damage_IsTimeBased.ptr() != Py_None )
            try {
                return func_Damage_IsTimeBased( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_SingleplayRules::Damage_IsTimeBased( iDmgType );
            }
        else
            return this->C_SingleplayRules::Damage_IsTimeBased( iDmgType );
    }
    
    bool default_Damage_IsTimeBased( int iDmgType ) {
        return C_SingleplayRules::Damage_IsTimeBased( iDmgType );
    }

    virtual bool Damage_NoPhysicsForce( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_NoPhysicsForce: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_NoPhysicsForce( iDmgType ) of Class: C_SingleplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_NoPhysicsForce = this->get_override( "Damage_NoPhysicsForce" );
        if( func_Damage_NoPhysicsForce.ptr() != Py_None )
            try {
                return func_Damage_NoPhysicsForce( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_SingleplayRules::Damage_NoPhysicsForce( iDmgType );
            }
        else
            return this->C_SingleplayRules::Damage_NoPhysicsForce( iDmgType );
    }
    
    bool default_Damage_NoPhysicsForce( int iDmgType ) {
        return C_SingleplayRules::Damage_NoPhysicsForce( iDmgType );
    }

    virtual bool Damage_ShouldGibCorpse( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_ShouldGibCorpse: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_ShouldGibCorpse( iDmgType ) of Class: C_SingleplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_ShouldGibCorpse = this->get_override( "Damage_ShouldGibCorpse" );
        if( func_Damage_ShouldGibCorpse.ptr() != Py_None )
            try {
                return func_Damage_ShouldGibCorpse( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_SingleplayRules::Damage_ShouldGibCorpse( iDmgType );
            }
        else
            return this->C_SingleplayRules::Damage_ShouldGibCorpse( iDmgType );
    }
    
    bool default_Damage_ShouldGibCorpse( int iDmgType ) {
        return C_SingleplayRules::Damage_ShouldGibCorpse( iDmgType );
    }

    virtual bool Damage_ShouldNotBleed( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_ShouldNotBleed: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_ShouldNotBleed( iDmgType ) of Class: C_SingleplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_ShouldNotBleed = this->get_override( "Damage_ShouldNotBleed" );
        if( func_Damage_ShouldNotBleed.ptr() != Py_None )
            try {
                return func_Damage_ShouldNotBleed( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_SingleplayRules::Damage_ShouldNotBleed( iDmgType );
            }
        else
            return this->C_SingleplayRules::Damage_ShouldNotBleed( iDmgType );
    }
    
    bool default_Damage_ShouldNotBleed( int iDmgType ) {
        return C_SingleplayRules::Damage_ShouldNotBleed( iDmgType );
    }

    virtual bool Damage_ShowOnHUD( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_ShowOnHUD: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_ShowOnHUD( iDmgType ) of Class: C_SingleplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_ShowOnHUD = this->get_override( "Damage_ShowOnHUD" );
        if( func_Damage_ShowOnHUD.ptr() != Py_None )
            try {
                return func_Damage_ShowOnHUD( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_SingleplayRules::Damage_ShowOnHUD( iDmgType );
            }
        else
            return this->C_SingleplayRules::Damage_ShowOnHUD( iDmgType );
    }
    
    bool default_Damage_ShowOnHUD( int iDmgType ) {
        return C_SingleplayRules::Damage_ShowOnHUD( iDmgType );
    }

    virtual bool IsMultiplayer(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsMultiplayer: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsMultiplayer(  ) of Class: C_SingleplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsMultiplayer = this->get_override( "IsMultiplayer" );
        if( func_IsMultiplayer.ptr() != Py_None )
            try {
                return func_IsMultiplayer(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_SingleplayRules::IsMultiplayer(  );
            }
        else
            return this->C_SingleplayRules::IsMultiplayer(  );
    }
    
    bool default_IsMultiplayer(  ) {
        return C_SingleplayRules::IsMultiplayer( );
    }

    virtual bool AllowMapParticleEffect( char const * pszParticleEffect ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AllowMapParticleEffect: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AllowMapParticleEffect( pszParticleEffect ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AllowMapParticleEffect = this->get_override( "AllowMapParticleEffect" );
        if( func_AllowMapParticleEffect.ptr() != Py_None )
            try {
                return func_AllowMapParticleEffect( pszParticleEffect );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::AllowMapParticleEffect( pszParticleEffect );
            }
        else
            return this->C_GameRules::AllowMapParticleEffect( pszParticleEffect );
    }
    
    bool default_AllowMapParticleEffect( char const * pszParticleEffect ) {
        return C_GameRules::AllowMapParticleEffect( pszParticleEffect );
    }

    virtual bool AllowMapVisionFilterShaders(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AllowMapVisionFilterShaders: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AllowMapVisionFilterShaders(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AllowMapVisionFilterShaders = this->get_override( "AllowMapVisionFilterShaders" );
        if( func_AllowMapVisionFilterShaders.ptr() != Py_None )
            try {
                return func_AllowMapVisionFilterShaders(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::AllowMapVisionFilterShaders(  );
            }
        else
            return this->C_GameRules::AllowMapVisionFilterShaders(  );
    }
    
    bool default_AllowMapVisionFilterShaders(  ) {
        return C_GameRules::AllowMapVisionFilterShaders( );
    }

    virtual bool AllowThirdPersonCamera(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AllowThirdPersonCamera: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AllowThirdPersonCamera(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AllowThirdPersonCamera = this->get_override( "AllowThirdPersonCamera" );
        if( func_AllowThirdPersonCamera.ptr() != Py_None )
            try {
                return func_AllowThirdPersonCamera(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::AllowThirdPersonCamera(  );
            }
        else
            return this->C_GameRules::AllowThirdPersonCamera(  );
    }
    
    bool default_AllowThirdPersonCamera(  ) {
        return C_GameRules::AllowThirdPersonCamera( );
    }

    virtual bool AllowWeatherParticles(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AllowWeatherParticles: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AllowWeatherParticles(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AllowWeatherParticles = this->get_override( "AllowWeatherParticles" );
        if( func_AllowWeatherParticles.ptr() != Py_None )
            try {
                return func_AllowWeatherParticles(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::AllowWeatherParticles(  );
            }
        else
            return this->C_GameRules::AllowWeatherParticles(  );
    }
    
    bool default_AllowWeatherParticles(  ) {
        return C_GameRules::AllowWeatherParticles( );
    }

    virtual void ClientCommandKeyValues( ::edict_t * pEntity, ::KeyValues * pKeyValues ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientCommandKeyValues: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientCommandKeyValues = this->get_override( "ClientCommandKeyValues" );
        if( func_ClientCommandKeyValues.ptr() != Py_None )
            try {
                func_ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) );
            }
        else
            this->C_GameRules::ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) );
    }
    
    void default_ClientCommandKeyValues( ::edict_t * pEntity, ::KeyValues * pKeyValues ) {
        C_GameRules::ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) );
    }

    virtual void ClientSpawned( ::edict_t * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientSpawned: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ClientSpawned( boost::python::ptr(pPlayer) ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientSpawned = this->get_override( "ClientSpawned" );
        if( func_ClientSpawned.ptr() != Py_None )
            try {
                func_ClientSpawned( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::ClientSpawned( boost::python::ptr(pPlayer) );
            }
        else
            this->C_GameRules::ClientSpawned( boost::python::ptr(pPlayer) );
    }
    
    void default_ClientSpawned( ::edict_t * pPlayer ) {
        C_GameRules::ClientSpawned( boost::python::ptr(pPlayer) );
    }

    virtual int DefaultFOV(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "DefaultFOV: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling DefaultFOV(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_DefaultFOV = this->get_override( "DefaultFOV" );
        if( func_DefaultFOV.ptr() != Py_None )
            try {
                return func_DefaultFOV(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::DefaultFOV(  );
            }
        else
            return this->C_GameRules::DefaultFOV(  );
    }
    
    int default_DefaultFOV(  ) {
        return C_GameRules::DefaultFOV( );
    }

    virtual float GetDamageMultiplier(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetDamageMultiplier: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetDamageMultiplier(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetDamageMultiplier = this->get_override( "GetDamageMultiplier" );
        if( func_GetDamageMultiplier.ptr() != Py_None )
            try {
                return func_GetDamageMultiplier(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::GetDamageMultiplier(  );
            }
        else
            return this->C_GameRules::GetDamageMultiplier(  );
    }
    
    float default_GetDamageMultiplier(  ) {
        return C_GameRules::GetDamageMultiplier( );
    }

    virtual int GetGameType(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetGameType: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetGameType(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetGameType = this->get_override( "GetGameType" );
        if( func_GetGameType.ptr() != Py_None )
            try {
                return func_GetGameType(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::GetGameType(  );
            }
        else
            return this->C_GameRules::GetGameType(  );
    }
    
    int default_GetGameType(  ) {
        return C_GameRules::GetGameType( );
    }

    virtual char const * GetGameTypeName(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetGameTypeName: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetGameTypeName(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetGameTypeName = this->get_override( "GetGameTypeName" );
        if( func_GetGameTypeName.ptr() != Py_None )
            try {
                return func_GetGameTypeName(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::GetGameTypeName(  );
            }
        else
            return this->C_GameRules::GetGameTypeName(  );
    }
    
    char const * default_GetGameTypeName(  ) {
        return C_GameRules::GetGameTypeName( );
    }

    virtual ::C_BaseCombatWeapon * GetNextBestWeapon( ::C_BaseCombatCharacter * pPlayer, ::C_BaseCombatWeapon * pCurrentWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetNextBestWeapon: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetNextBestWeapon = this->get_override( "GetNextBestWeapon" );
        if( func_GetNextBestWeapon.ptr() != Py_None )
            try {
                return func_GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
            }
        else
            return this->C_GameRules::GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
    }
    
    ::C_BaseCombatWeapon * default_GetNextBestWeapon( ::C_BaseCombatCharacter * pPlayer, ::C_BaseCombatWeapon * pCurrentWeapon ) {
        return C_GameRules::GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
    }

    virtual bool InRoundRestart(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "InRoundRestart: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling InRoundRestart(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_InRoundRestart = this->get_override( "InRoundRestart" );
        if( func_InRoundRestart.ptr() != Py_None )
            try {
                return func_InRoundRestart(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::InRoundRestart(  );
            }
        else
            return this->C_GameRules::InRoundRestart(  );
    }
    
    bool default_InRoundRestart(  ) {
        return C_GameRules::InRoundRestart( );
    }

    virtual void InitGamerules(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "InitGamerules: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling InitGamerules(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_InitGamerules = this->get_override( "InitGamerules" );
        if( func_InitGamerules.ptr() != Py_None )
            try {
                func_InitGamerules(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::InitGamerules(  );
            }
        else
            this->C_GameRules::InitGamerules(  );
    }
    
    void default_InitGamerules(  ) {
        C_GameRules::InitGamerules( );
    }

    virtual bool IsBonusChallengeTimeBased(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsBonusChallengeTimeBased: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsBonusChallengeTimeBased(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsBonusChallengeTimeBased = this->get_override( "IsBonusChallengeTimeBased" );
        if( func_IsBonusChallengeTimeBased.ptr() != Py_None )
            try {
                return func_IsBonusChallengeTimeBased(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::IsBonusChallengeTimeBased(  );
            }
        else
            return this->C_GameRules::IsBonusChallengeTimeBased(  );
    }
    
    bool default_IsBonusChallengeTimeBased(  ) {
        return C_GameRules::IsBonusChallengeTimeBased( );
    }

    virtual bool IsConnectedUserInfoChangeAllowed( ::C_BasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsConnectedUserInfoChangeAllowed: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsConnectedUserInfoChangeAllowed = this->get_override( "IsConnectedUserInfoChangeAllowed" );
        if( func_IsConnectedUserInfoChangeAllowed.ptr() != Py_None )
            try {
                return func_IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) );
            }
        else
            return this->C_GameRules::IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) );
    }
    
    bool default_IsConnectedUserInfoChangeAllowed( ::C_BasePlayer * pPlayer ) {
        return C_GameRules::IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) );
    }

    virtual bool IsHolidayActive( int eHoliday ) const  {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsHolidayActive: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsHolidayActive( eHoliday ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsHolidayActive = this->get_override( "IsHolidayActive" );
        if( func_IsHolidayActive.ptr() != Py_None )
            try {
                return func_IsHolidayActive( eHoliday );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::IsHolidayActive( eHoliday );
            }
        else
            return this->C_GameRules::IsHolidayActive( eHoliday );
    }
    
    bool default_IsHolidayActive( int eHoliday ) const  {
        return C_GameRules::IsHolidayActive( eHoliday );
    }

    virtual bool IsLocalPlayer( int nEntIndex ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsLocalPlayer: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsLocalPlayer( nEntIndex ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsLocalPlayer = this->get_override( "IsLocalPlayer" );
        if( func_IsLocalPlayer.ptr() != Py_None )
            try {
                return func_IsLocalPlayer( nEntIndex );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::IsLocalPlayer( nEntIndex );
            }
        else
            return this->C_GameRules::IsLocalPlayer( nEntIndex );
    }
    
    bool default_IsLocalPlayer( int nEntIndex ) {
        return C_GameRules::IsLocalPlayer( nEntIndex );
    }

    virtual void ModifySentChat( char * pBuf, int iBufSize ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ModifySentChat: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ModifySentChat( pBuf, iBufSize ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ModifySentChat = this->get_override( "ModifySentChat" );
        if( func_ModifySentChat.ptr() != Py_None )
            try {
                func_ModifySentChat( pBuf, iBufSize );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::ModifySentChat( pBuf, iBufSize );
            }
        else
            this->C_GameRules::ModifySentChat( pBuf, iBufSize );
    }
    
    void default_ModifySentChat( char * pBuf, int iBufSize ) {
        C_GameRules::ModifySentChat( pBuf, iBufSize );
    }

    virtual char const * Name(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Name: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Name(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Name = this->get_override( "Name" );
        if( func_Name.ptr() != Py_None )
            try {
                return func_Name(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::Name(  );
            }
        else
            return this->C_GameRules::Name(  );
    }
    
    char const * default_Name(  ) {
        return C_GameRules::Name( );
    }

    virtual void OnFileReceived( char const * fileName, unsigned int transferID ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnFileReceived: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnFileReceived( fileName, transferID ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnFileReceived = this->get_override( "OnFileReceived" );
        if( func_OnFileReceived.ptr() != Py_None )
            try {
                func_OnFileReceived( fileName, transferID );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::OnFileReceived( fileName, transferID );
            }
        else
            this->C_GameRules::OnFileReceived( fileName, transferID );
    }
    
    void default_OnFileReceived( char const * fileName, unsigned int transferID ) {
        C_GameRules::OnFileReceived( fileName, transferID );
    }

    virtual bool ShouldDrawHeadLabels(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShouldDrawHeadLabels: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShouldDrawHeadLabels(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShouldDrawHeadLabels = this->get_override( "ShouldDrawHeadLabels" );
        if( func_ShouldDrawHeadLabels.ptr() != Py_None )
            try {
                return func_ShouldDrawHeadLabels(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::ShouldDrawHeadLabels(  );
            }
        else
            return this->C_GameRules::ShouldDrawHeadLabels(  );
    }
    
    bool default_ShouldDrawHeadLabels(  ) {
        return C_GameRules::ShouldDrawHeadLabels( );
    }

    virtual bool ShouldWarnOfAbandonOnQuit(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShouldWarnOfAbandonOnQuit: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShouldWarnOfAbandonOnQuit(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShouldWarnOfAbandonOnQuit = this->get_override( "ShouldWarnOfAbandonOnQuit" );
        if( func_ShouldWarnOfAbandonOnQuit.ptr() != Py_None )
            try {
                return func_ShouldWarnOfAbandonOnQuit(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::ShouldWarnOfAbandonOnQuit(  );
            }
        else
            return this->C_GameRules::ShouldWarnOfAbandonOnQuit(  );
    }
    
    bool default_ShouldWarnOfAbandonOnQuit(  ) {
        return C_GameRules::ShouldWarnOfAbandonOnQuit( );
    }

    virtual void ShutdownGamerules(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShutdownGamerules: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShutdownGamerules(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShutdownGamerules = this->get_override( "ShutdownGamerules" );
        if( func_ShutdownGamerules.ptr() != Py_None )
            try {
                func_ShutdownGamerules(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::ShutdownGamerules(  );
            }
        else
            this->C_GameRules::ShutdownGamerules(  );
    }
    
    void default_ShutdownGamerules(  ) {
        C_GameRules::ShutdownGamerules( );
    }

    virtual bool SwitchToNextBestWeapon( ::C_BaseCombatCharacter * pPlayer, ::C_BaseCombatWeapon * pCurrentWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SwitchToNextBestWeapon: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SwitchToNextBestWeapon = this->get_override( "SwitchToNextBestWeapon" );
        if( func_SwitchToNextBestWeapon.ptr() != Py_None )
            try {
                return func_SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
            }
        else
            return this->C_GameRules::SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
    }
    
    bool default_SwitchToNextBestWeapon( ::C_BaseCombatCharacter * pPlayer, ::C_BaseCombatWeapon * pCurrentWeapon ) {
        return C_GameRules::SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
    }

    virtual char const * TranslateEffectForVisionFilter( char const * pchEffectType, char const * pchEffectName ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "TranslateEffectForVisionFilter: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling TranslateEffectForVisionFilter( pchEffectType, pchEffectName ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_TranslateEffectForVisionFilter = this->get_override( "TranslateEffectForVisionFilter" );
        if( func_TranslateEffectForVisionFilter.ptr() != Py_None )
            try {
                return func_TranslateEffectForVisionFilter( pchEffectType, pchEffectName );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::TranslateEffectForVisionFilter( pchEffectType, pchEffectName );
            }
        else
            return this->C_GameRules::TranslateEffectForVisionFilter( pchEffectType, pchEffectName );
    }
    
    char const * default_TranslateEffectForVisionFilter( char const * pchEffectType, char const * pchEffectName ) {
        return C_GameRules::TranslateEffectForVisionFilter( pchEffectType, pchEffectName );
    }

    virtual PyObject *GetPySelf() const { return boost::python::detail::wrapper_base_::get_owner(*this); }

};

void register_CSingleplayRules_class(){

    bp::class_< C_SingleplayRules_wrapper, bp::bases< C_GameRules > >( "CSingleplayRules" )    
        .def( 
            "Damage_GetNoPhysicsForce"
            , (int ( ::C_SingleplayRules::* )(  ) )(&::C_SingleplayRules::Damage_GetNoPhysicsForce)
            , (int ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_Damage_GetNoPhysicsForce) )    
        .def( 
            "Damage_GetShouldGibCorpse"
            , (int ( ::C_SingleplayRules::* )(  ) )(&::C_SingleplayRules::Damage_GetShouldGibCorpse)
            , (int ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_Damage_GetShouldGibCorpse) )    
        .def( 
            "Damage_GetShouldNotBleed"
            , (int ( ::C_SingleplayRules::* )(  ) )(&::C_SingleplayRules::Damage_GetShouldNotBleed)
            , (int ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_Damage_GetShouldNotBleed) )    
        .def( 
            "Damage_GetShowOnHud"
            , (int ( ::C_SingleplayRules::* )(  ) )(&::C_SingleplayRules::Damage_GetShowOnHud)
            , (int ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_Damage_GetShowOnHud) )    
        .def( 
            "Damage_GetTimeBased"
            , (int ( ::C_SingleplayRules::* )(  ) )(&::C_SingleplayRules::Damage_GetTimeBased)
            , (int ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_Damage_GetTimeBased) )    
        .def( 
            "Damage_IsTimeBased"
            , (bool ( ::C_SingleplayRules::* )( int ) )(&::C_SingleplayRules::Damage_IsTimeBased)
            , (bool ( C_SingleplayRules_wrapper::* )( int ) )(&C_SingleplayRules_wrapper::default_Damage_IsTimeBased)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_NoPhysicsForce"
            , (bool ( ::C_SingleplayRules::* )( int ) )(&::C_SingleplayRules::Damage_NoPhysicsForce)
            , (bool ( C_SingleplayRules_wrapper::* )( int ) )(&C_SingleplayRules_wrapper::default_Damage_NoPhysicsForce)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_ShouldGibCorpse"
            , (bool ( ::C_SingleplayRules::* )( int ) )(&::C_SingleplayRules::Damage_ShouldGibCorpse)
            , (bool ( C_SingleplayRules_wrapper::* )( int ) )(&C_SingleplayRules_wrapper::default_Damage_ShouldGibCorpse)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_ShouldNotBleed"
            , (bool ( ::C_SingleplayRules::* )( int ) )(&::C_SingleplayRules::Damage_ShouldNotBleed)
            , (bool ( C_SingleplayRules_wrapper::* )( int ) )(&C_SingleplayRules_wrapper::default_Damage_ShouldNotBleed)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_ShowOnHUD"
            , (bool ( ::C_SingleplayRules::* )( int ) )(&::C_SingleplayRules::Damage_ShowOnHUD)
            , (bool ( C_SingleplayRules_wrapper::* )( int ) )(&C_SingleplayRules_wrapper::default_Damage_ShowOnHUD)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "IsMultiplayer"
            , (bool ( ::C_SingleplayRules::* )(  ) )(&::C_SingleplayRules::IsMultiplayer)
            , (bool ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_IsMultiplayer) )    
        .def( 
            "AllowMapParticleEffect"
            , (bool ( ::C_GameRules::* )( char const * ) )(&::C_GameRules::AllowMapParticleEffect)
            , (bool ( C_SingleplayRules_wrapper::* )( char const * ) )(&C_SingleplayRules_wrapper::default_AllowMapParticleEffect)
            , ( bp::arg("pszParticleEffect") ) )    
        .def( 
            "AllowMapVisionFilterShaders"
            , (bool ( ::C_GameRules::* )(  ) )(&::C_GameRules::AllowMapVisionFilterShaders)
            , (bool ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_AllowMapVisionFilterShaders) )    
        .def( 
            "AllowThirdPersonCamera"
            , (bool ( ::C_GameRules::* )(  ) )(&::C_GameRules::AllowThirdPersonCamera)
            , (bool ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_AllowThirdPersonCamera) )    
        .def( 
            "AllowWeatherParticles"
            , (bool ( ::C_GameRules::* )(  ) )(&::C_GameRules::AllowWeatherParticles)
            , (bool ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_AllowWeatherParticles) )    
        .def( 
            "ClientCommandKeyValues"
            , (void ( ::C_GameRules::* )( ::edict_t *,::KeyValues * ) )(&::C_GameRules::ClientCommandKeyValues)
            , (void ( C_SingleplayRules_wrapper::* )( ::edict_t *,::KeyValues * ) )(&C_SingleplayRules_wrapper::default_ClientCommandKeyValues)
            , ( bp::arg("pEntity"), bp::arg("pKeyValues") ) )    
        .def( 
            "ClientSpawned"
            , (void ( ::C_GameRules::* )( ::edict_t * ) )(&::C_GameRules::ClientSpawned)
            , (void ( C_SingleplayRules_wrapper::* )( ::edict_t * ) )(&C_SingleplayRules_wrapper::default_ClientSpawned)
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "DefaultFOV"
            , (int ( ::C_GameRules::* )(  ) )(&::C_GameRules::DefaultFOV)
            , (int ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_DefaultFOV) )    
        .def( 
            "GetDamageMultiplier"
            , (float ( ::C_GameRules::* )(  ) )(&::C_GameRules::GetDamageMultiplier)
            , (float ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_GetDamageMultiplier) )    
        .def( 
            "GetGameType"
            , (int ( ::C_GameRules::* )(  ) )(&::C_GameRules::GetGameType)
            , (int ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_GetGameType) )    
        .def( 
            "GetGameTypeName"
            , (char const * ( ::C_GameRules::* )(  ) )(&::C_GameRules::GetGameTypeName)
            , (char const * ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_GetGameTypeName) )    
        .def( 
            "GetNextBestWeapon"
            , (::C_BaseCombatWeapon * ( ::C_GameRules::* )( ::C_BaseCombatCharacter *,::C_BaseCombatWeapon * ) )(&::C_GameRules::GetNextBestWeapon)
            , (::C_BaseCombatWeapon * ( C_SingleplayRules_wrapper::* )( ::C_BaseCombatCharacter *,::C_BaseCombatWeapon * ) )(&C_SingleplayRules_wrapper::default_GetNextBestWeapon)
            , ( bp::arg("pPlayer"), bp::arg("pCurrentWeapon") )
            , bp::return_value_policy< bp::return_by_value >() )    
        .def( 
            "InRoundRestart"
            , (bool ( ::C_GameRules::* )(  ) )(&::C_GameRules::InRoundRestart)
            , (bool ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_InRoundRestart) )    
        .def( 
            "InitGamerules"
            , (void ( ::C_GameRules::* )(  ) )(&::C_GameRules::InitGamerules)
            , (void ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_InitGamerules) )    
        .def( 
            "IsBonusChallengeTimeBased"
            , (bool ( ::C_GameRules::* )(  ) )(&::C_GameRules::IsBonusChallengeTimeBased)
            , (bool ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_IsBonusChallengeTimeBased) )    
        .def( 
            "IsConnectedUserInfoChangeAllowed"
            , (bool ( ::C_GameRules::* )( ::C_BasePlayer * ) )(&::C_GameRules::IsConnectedUserInfoChangeAllowed)
            , (bool ( C_SingleplayRules_wrapper::* )( ::C_BasePlayer * ) )(&C_SingleplayRules_wrapper::default_IsConnectedUserInfoChangeAllowed)
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "IsHolidayActive"
            , (bool ( ::C_GameRules::* )( int ) const)(&::C_GameRules::IsHolidayActive)
            , (bool ( C_SingleplayRules_wrapper::* )( int ) const)(&C_SingleplayRules_wrapper::default_IsHolidayActive)
            , ( bp::arg("eHoliday") ) )    
        .def( 
            "IsLocalPlayer"
            , (bool ( ::C_GameRules::* )( int ) )(&::C_GameRules::IsLocalPlayer)
            , (bool ( C_SingleplayRules_wrapper::* )( int ) )(&C_SingleplayRules_wrapper::default_IsLocalPlayer)
            , ( bp::arg("nEntIndex") ) )    
        .def( 
            "ModifySentChat"
            , (void ( ::C_GameRules::* )( char *,int ) )(&::C_GameRules::ModifySentChat)
            , (void ( C_SingleplayRules_wrapper::* )( char *,int ) )(&C_SingleplayRules_wrapper::default_ModifySentChat)
            , ( bp::arg("pBuf"), bp::arg("iBufSize") ) )    
        .def( 
            "Name"
            , (char const * ( ::C_GameRules::* )(  ) )(&::C_GameRules::Name)
            , (char const * ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_Name) )    
        .def( 
            "OnFileReceived"
            , (void ( ::C_GameRules::* )( char const *,unsigned int ) )(&::C_GameRules::OnFileReceived)
            , (void ( C_SingleplayRules_wrapper::* )( char const *,unsigned int ) )(&C_SingleplayRules_wrapper::default_OnFileReceived)
            , ( bp::arg("fileName"), bp::arg("transferID") ) )    
        .def( 
            "ShouldDrawHeadLabels"
            , (bool ( ::C_GameRules::* )(  ) )(&::C_GameRules::ShouldDrawHeadLabels)
            , (bool ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_ShouldDrawHeadLabels) )    
        .def( 
            "ShouldWarnOfAbandonOnQuit"
            , (bool ( ::C_GameRules::* )(  ) )(&::C_GameRules::ShouldWarnOfAbandonOnQuit)
            , (bool ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_ShouldWarnOfAbandonOnQuit) )    
        .def( 
            "ShutdownGamerules"
            , (void ( ::C_GameRules::* )(  ) )(&::C_GameRules::ShutdownGamerules)
            , (void ( C_SingleplayRules_wrapper::* )(  ) )(&C_SingleplayRules_wrapper::default_ShutdownGamerules) )    
        .def( 
            "SwitchToNextBestWeapon"
            , (bool ( ::C_GameRules::* )( ::C_BaseCombatCharacter *,::C_BaseCombatWeapon * ) )(&::C_GameRules::SwitchToNextBestWeapon)
            , (bool ( C_SingleplayRules_wrapper::* )( ::C_BaseCombatCharacter *,::C_BaseCombatWeapon * ) )(&C_SingleplayRules_wrapper::default_SwitchToNextBestWeapon)
            , ( bp::arg("pPlayer"), bp::arg("pCurrentWeapon") ) )    
        .def( 
            "TranslateEffectForVisionFilter"
            , (char const * ( ::C_GameRules::* )( char const *,char const * ) )(&::C_GameRules::TranslateEffectForVisionFilter)
            , (char const * ( C_SingleplayRules_wrapper::* )( char const *,char const * ) )(&C_SingleplayRules_wrapper::default_TranslateEffectForVisionFilter)
            , ( bp::arg("pchEffectType"), bp::arg("pchEffectName") ) );

}

