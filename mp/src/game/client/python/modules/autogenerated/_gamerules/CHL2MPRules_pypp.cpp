// This file has been generated by Py++.

#include "cbase.h"
// This file has been generated by Py++.

#include "cbase.h"
#include "gamerules.h"
#include "multiplay_gamerules.h"
#include "singleplay_gamerules.h"
#include "teamplay_gamerules.h"
#include "srcpy_gamerules.h"
#include "ammodef.h"
#include "takedamageinfo.h"
#include "hl2mp/hl2mp_gamerules.h"
#include "tier0/valve_minmax_off.h"
#include "srcpy.h"
#include "tier0/valve_minmax_on.h"
#include "tier0/memdbgon.h"
#include "CHL2MPRules_pypp.hpp"

namespace bp = boost::python;

struct C_HL2MPRules_wrapper : C_HL2MPRules, bp::wrapper< C_HL2MPRules > {

    C_HL2MPRules_wrapper( )
    : C_HL2MPRules( )
      , bp::wrapper< C_HL2MPRules >(){
        // null constructor
    
    }

    virtual bool ClientCommand( ::C_BaseEntity * pEdict, ::CCommand const & args ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientCommand: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ClientCommand( boost::python::ptr(pEdict), boost::ref(args) ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientCommand = this->get_override( "ClientCommand" );
        if( func_ClientCommand.ptr() != Py_None )
            try {
                return func_ClientCommand( boost::python::ptr(pEdict), boost::ref(args) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::ClientCommand( boost::python::ptr(pEdict), boost::ref(args) );
            }
        else
            return this->C_HL2MPRules::ClientCommand( boost::python::ptr(pEdict), boost::ref(args) );
    }
    
    bool default_ClientCommand( ::C_BaseEntity * pEdict, ::CCommand const & args ) {
        return C_HL2MPRules::ClientCommand( boost::python::ptr(pEdict), boost::ref(args) );
    }

    virtual void ClientDisconnected( ::edict_t * pClient ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientDisconnected: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ClientDisconnected( boost::python::ptr(pClient) ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientDisconnected = this->get_override( "ClientDisconnected" );
        if( func_ClientDisconnected.ptr() != Py_None )
            try {
                func_ClientDisconnected( boost::python::ptr(pClient) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2MPRules::ClientDisconnected( boost::python::ptr(pClient) );
            }
        else
            this->C_HL2MPRules::ClientDisconnected( boost::python::ptr(pClient) );
    }
    
    void default_ClientDisconnected( ::edict_t * pClient ) {
        C_HL2MPRules::ClientDisconnected( boost::python::ptr(pClient) );
    }

    virtual void ClientSettingsChanged( ::C_BasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientSettingsChanged: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ClientSettingsChanged( boost::python::ptr(pPlayer) ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientSettingsChanged = this->get_override( "ClientSettingsChanged" );
        if( func_ClientSettingsChanged.ptr() != Py_None )
            try {
                func_ClientSettingsChanged( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2MPRules::ClientSettingsChanged( boost::python::ptr(pPlayer) );
            }
        else
            this->C_HL2MPRules::ClientSettingsChanged( boost::python::ptr(pPlayer) );
    }
    
    void default_ClientSettingsChanged( ::C_BasePlayer * pPlayer ) {
        C_HL2MPRules::ClientSettingsChanged( boost::python::ptr(pPlayer) );
    }

    virtual void CreateStandardEntities(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "CreateStandardEntities: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling CreateStandardEntities(  ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_CreateStandardEntities = this->get_override( "CreateStandardEntities" );
        if( func_CreateStandardEntities.ptr() != Py_None )
            try {
                func_CreateStandardEntities(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2MPRules::CreateStandardEntities(  );
            }
        else
            this->C_HL2MPRules::CreateStandardEntities(  );
    }
    
    void default_CreateStandardEntities(  ) {
        C_HL2MPRules::CreateStandardEntities( );
    }

    virtual void DeathNotice( ::C_BasePlayer * pVictim, ::CTakeDamageInfo const & info ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "DeathNotice: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling DeathNotice( boost::python::ptr(pVictim), boost::ref(info) ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_DeathNotice = this->get_override( "DeathNotice" );
        if( func_DeathNotice.ptr() != Py_None )
            try {
                func_DeathNotice( boost::python::ptr(pVictim), boost::ref(info) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2MPRules::DeathNotice( boost::python::ptr(pVictim), boost::ref(info) );
            }
        else
            this->C_HL2MPRules::DeathNotice( boost::python::ptr(pVictim), boost::ref(info) );
    }
    
    void default_DeathNotice( ::C_BasePlayer * pVictim, ::CTakeDamageInfo const & info ) {
        C_HL2MPRules::DeathNotice( boost::python::ptr(pVictim), boost::ref(info) );
    }

    virtual float FlWeaponRespawnTime( ::C_BaseCombatWeapon * pWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FlWeaponRespawnTime: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FlWeaponRespawnTime( boost::python::ptr(pWeapon) ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FlWeaponRespawnTime = this->get_override( "FlWeaponRespawnTime" );
        if( func_FlWeaponRespawnTime.ptr() != Py_None )
            try {
                return func_FlWeaponRespawnTime( boost::python::ptr(pWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::FlWeaponRespawnTime( boost::python::ptr(pWeapon) );
            }
        else
            return this->C_HL2MPRules::FlWeaponRespawnTime( boost::python::ptr(pWeapon) );
    }
    
    float default_FlWeaponRespawnTime( ::C_BaseCombatWeapon * pWeapon ) {
        return C_HL2MPRules::FlWeaponRespawnTime( boost::python::ptr(pWeapon) );
    }

    virtual float FlWeaponTryRespawn( ::C_BaseCombatWeapon * pWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FlWeaponTryRespawn: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FlWeaponTryRespawn( boost::python::ptr(pWeapon) ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FlWeaponTryRespawn = this->get_override( "FlWeaponTryRespawn" );
        if( func_FlWeaponTryRespawn.ptr() != Py_None )
            try {
                return func_FlWeaponTryRespawn( boost::python::ptr(pWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::FlWeaponTryRespawn( boost::python::ptr(pWeapon) );
            }
        else
            return this->C_HL2MPRules::FlWeaponTryRespawn( boost::python::ptr(pWeapon) );
    }
    
    float default_FlWeaponTryRespawn( ::C_BaseCombatWeapon * pWeapon ) {
        return C_HL2MPRules::FlWeaponTryRespawn( boost::python::ptr(pWeapon) );
    }

    virtual char const * GetGameDescription(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetGameDescription: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetGameDescription(  ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetGameDescription = this->get_override( "GetGameDescription" );
        if( func_GetGameDescription.ptr() != Py_None )
            try {
                return func_GetGameDescription(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::GetGameDescription(  );
            }
        else
            return this->C_HL2MPRules::GetGameDescription(  );
    }
    
    char const * default_GetGameDescription(  ) {
        return C_HL2MPRules::GetGameDescription( );
    }

    virtual void GoToIntermission(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GoToIntermission: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GoToIntermission(  ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GoToIntermission = this->get_override( "GoToIntermission" );
        if( func_GoToIntermission.ptr() != Py_None )
            try {
                func_GoToIntermission(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2MPRules::GoToIntermission(  );
            }
        else
            this->C_HL2MPRules::GoToIntermission(  );
    }
    
    void default_GoToIntermission(  ) {
        C_HL2MPRules::GoToIntermission( );
    }

    virtual bool IsConnectedUserInfoChangeAllowed( ::C_BasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsConnectedUserInfoChangeAllowed: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsConnectedUserInfoChangeAllowed = this->get_override( "IsConnectedUserInfoChangeAllowed" );
        if( func_IsConnectedUserInfoChangeAllowed.ptr() != Py_None )
            try {
                return func_IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) );
            }
        else
            return this->C_HL2MPRules::IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) );
    }
    
    bool default_IsConnectedUserInfoChangeAllowed( ::C_BasePlayer * pPlayer ) {
        return C_HL2MPRules::IsConnectedUserInfoChangeAllowed( boost::python::ptr(pPlayer) );
    }

    virtual int PlayerRelationship( ::C_BaseEntity * pPlayer, ::C_BaseEntity * pTarget ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PlayerRelationship: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PlayerRelationship( boost::python::ptr(pPlayer), boost::python::ptr(pTarget) ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PlayerRelationship = this->get_override( "PlayerRelationship" );
        if( func_PlayerRelationship.ptr() != Py_None )
            try {
                return func_PlayerRelationship( boost::python::ptr(pPlayer), boost::python::ptr(pTarget) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::PlayerRelationship( boost::python::ptr(pPlayer), boost::python::ptr(pTarget) );
            }
        else
            return this->C_HL2MPRules::PlayerRelationship( boost::python::ptr(pPlayer), boost::python::ptr(pTarget) );
    }
    
    int default_PlayerRelationship( ::C_BaseEntity * pPlayer, ::C_BaseEntity * pTarget ) {
        return C_HL2MPRules::PlayerRelationship( boost::python::ptr(pPlayer), boost::python::ptr(pTarget) );
    }

    virtual void Precache(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Precache: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Precache(  ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Precache = this->get_override( "Precache" );
        if( func_Precache.ptr() != Py_None )
            try {
                func_Precache(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2MPRules::Precache(  );
            }
        else
            this->C_HL2MPRules::Precache(  );
    }
    
    void default_Precache(  ) {
        C_HL2MPRules::Precache( );
    }

    virtual void Think(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Think: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Think(  ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Think = this->get_override( "Think" );
        if( func_Think.ptr() != Py_None )
            try {
                func_Think(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2MPRules::Think(  );
            }
        else
            this->C_HL2MPRules::Think(  );
    }
    
    void default_Think(  ) {
        C_HL2MPRules::Think( );
    }

    virtual ::Vector VecWeaponRespawnSpot( ::C_BaseCombatWeapon * pWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "VecWeaponRespawnSpot: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling VecWeaponRespawnSpot( boost::python::ptr(pWeapon) ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_VecWeaponRespawnSpot = this->get_override( "VecWeaponRespawnSpot" );
        if( func_VecWeaponRespawnSpot.ptr() != Py_None )
            try {
                return func_VecWeaponRespawnSpot( boost::python::ptr(pWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::VecWeaponRespawnSpot( boost::python::ptr(pWeapon) );
            }
        else
            return this->C_HL2MPRules::VecWeaponRespawnSpot( boost::python::ptr(pWeapon) );
    }
    
    ::Vector default_VecWeaponRespawnSpot( ::C_BaseCombatWeapon * pWeapon ) {
        return C_HL2MPRules::VecWeaponRespawnSpot( boost::python::ptr(pWeapon) );
    }

    virtual int WeaponShouldRespawn( ::C_BaseCombatWeapon * pWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "WeaponShouldRespawn: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling WeaponShouldRespawn( boost::python::ptr(pWeapon) ) of Class: C_HL2MPRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_WeaponShouldRespawn = this->get_override( "WeaponShouldRespawn" );
        if( func_WeaponShouldRespawn.ptr() != Py_None )
            try {
                return func_WeaponShouldRespawn( boost::python::ptr(pWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::WeaponShouldRespawn( boost::python::ptr(pWeapon) );
            }
        else
            return this->C_HL2MPRules::WeaponShouldRespawn( boost::python::ptr(pWeapon) );
    }
    
    int default_WeaponShouldRespawn( ::C_BaseCombatWeapon * pWeapon ) {
        return C_HL2MPRules::WeaponShouldRespawn( boost::python::ptr(pWeapon) );
    }

    virtual bool AllowMapParticleEffect( char const * pszParticleEffect ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AllowMapParticleEffect: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AllowMapParticleEffect( pszParticleEffect ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AllowMapParticleEffect = this->get_override( "AllowMapParticleEffect" );
        if( func_AllowMapParticleEffect.ptr() != Py_None )
            try {
                return func_AllowMapParticleEffect( pszParticleEffect );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::AllowMapParticleEffect( pszParticleEffect );
            }
        else
            return this->C_GameRules::AllowMapParticleEffect( pszParticleEffect );
    }
    
    bool default_AllowMapParticleEffect( char const * pszParticleEffect ) {
        return C_GameRules::AllowMapParticleEffect( pszParticleEffect );
    }

    virtual bool AllowMapVisionFilterShaders(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AllowMapVisionFilterShaders: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AllowMapVisionFilterShaders(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AllowMapVisionFilterShaders = this->get_override( "AllowMapVisionFilterShaders" );
        if( func_AllowMapVisionFilterShaders.ptr() != Py_None )
            try {
                return func_AllowMapVisionFilterShaders(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::AllowMapVisionFilterShaders(  );
            }
        else
            return this->C_GameRules::AllowMapVisionFilterShaders(  );
    }
    
    bool default_AllowMapVisionFilterShaders(  ) {
        return C_GameRules::AllowMapVisionFilterShaders( );
    }

    virtual bool AllowThirdPersonCamera(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AllowThirdPersonCamera: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AllowThirdPersonCamera(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AllowThirdPersonCamera = this->get_override( "AllowThirdPersonCamera" );
        if( func_AllowThirdPersonCamera.ptr() != Py_None )
            try {
                return func_AllowThirdPersonCamera(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::AllowThirdPersonCamera(  );
            }
        else
            return this->C_GameRules::AllowThirdPersonCamera(  );
    }
    
    bool default_AllowThirdPersonCamera(  ) {
        return C_GameRules::AllowThirdPersonCamera( );
    }

    virtual bool AllowWeatherParticles(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AllowWeatherParticles: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AllowWeatherParticles(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AllowWeatherParticles = this->get_override( "AllowWeatherParticles" );
        if( func_AllowWeatherParticles.ptr() != Py_None )
            try {
                return func_AllowWeatherParticles(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::AllowWeatherParticles(  );
            }
        else
            return this->C_GameRules::AllowWeatherParticles(  );
    }
    
    bool default_AllowWeatherParticles(  ) {
        return C_GameRules::AllowWeatherParticles( );
    }

    virtual void ClientCommandKeyValues( ::edict_t * pEntity, ::KeyValues * pKeyValues ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientCommandKeyValues: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientCommandKeyValues = this->get_override( "ClientCommandKeyValues" );
        if( func_ClientCommandKeyValues.ptr() != Py_None )
            try {
                func_ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) );
            }
        else
            this->C_GameRules::ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) );
    }
    
    void default_ClientCommandKeyValues( ::edict_t * pEntity, ::KeyValues * pKeyValues ) {
        C_GameRules::ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) );
    }

    virtual void ClientSpawned( ::edict_t * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientSpawned: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ClientSpawned( boost::python::ptr(pPlayer) ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientSpawned = this->get_override( "ClientSpawned" );
        if( func_ClientSpawned.ptr() != Py_None )
            try {
                func_ClientSpawned( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::ClientSpawned( boost::python::ptr(pPlayer) );
            }
        else
            this->C_GameRules::ClientSpawned( boost::python::ptr(pPlayer) );
    }
    
    void default_ClientSpawned( ::edict_t * pPlayer ) {
        C_GameRules::ClientSpawned( boost::python::ptr(pPlayer) );
    }

    virtual int Damage_GetNoPhysicsForce(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetNoPhysicsForce: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetNoPhysicsForce(  ) of Class: C_MultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetNoPhysicsForce = this->get_override( "Damage_GetNoPhysicsForce" );
        if( func_Damage_GetNoPhysicsForce.ptr() != Py_None )
            try {
                return func_Damage_GetNoPhysicsForce(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_GetNoPhysicsForce(  );
            }
        else
            return this->C_MultiplayRules::Damage_GetNoPhysicsForce(  );
    }
    
    int default_Damage_GetNoPhysicsForce(  ) {
        return C_MultiplayRules::Damage_GetNoPhysicsForce( );
    }

    virtual int Damage_GetShouldGibCorpse(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetShouldGibCorpse: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetShouldGibCorpse(  ) of Class: C_MultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetShouldGibCorpse = this->get_override( "Damage_GetShouldGibCorpse" );
        if( func_Damage_GetShouldGibCorpse.ptr() != Py_None )
            try {
                return func_Damage_GetShouldGibCorpse(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_GetShouldGibCorpse(  );
            }
        else
            return this->C_MultiplayRules::Damage_GetShouldGibCorpse(  );
    }
    
    int default_Damage_GetShouldGibCorpse(  ) {
        return C_MultiplayRules::Damage_GetShouldGibCorpse( );
    }

    virtual int Damage_GetShouldNotBleed(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetShouldNotBleed: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetShouldNotBleed(  ) of Class: C_MultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetShouldNotBleed = this->get_override( "Damage_GetShouldNotBleed" );
        if( func_Damage_GetShouldNotBleed.ptr() != Py_None )
            try {
                return func_Damage_GetShouldNotBleed(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_GetShouldNotBleed(  );
            }
        else
            return this->C_MultiplayRules::Damage_GetShouldNotBleed(  );
    }
    
    int default_Damage_GetShouldNotBleed(  ) {
        return C_MultiplayRules::Damage_GetShouldNotBleed( );
    }

    virtual int Damage_GetShowOnHud(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetShowOnHud: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetShowOnHud(  ) of Class: C_MultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetShowOnHud = this->get_override( "Damage_GetShowOnHud" );
        if( func_Damage_GetShowOnHud.ptr() != Py_None )
            try {
                return func_Damage_GetShowOnHud(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_GetShowOnHud(  );
            }
        else
            return this->C_MultiplayRules::Damage_GetShowOnHud(  );
    }
    
    int default_Damage_GetShowOnHud(  ) {
        return C_MultiplayRules::Damage_GetShowOnHud( );
    }

    virtual int Damage_GetTimeBased(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_GetTimeBased: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_GetTimeBased(  ) of Class: C_MultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_GetTimeBased = this->get_override( "Damage_GetTimeBased" );
        if( func_Damage_GetTimeBased.ptr() != Py_None )
            try {
                return func_Damage_GetTimeBased(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_GetTimeBased(  );
            }
        else
            return this->C_MultiplayRules::Damage_GetTimeBased(  );
    }
    
    int default_Damage_GetTimeBased(  ) {
        return C_MultiplayRules::Damage_GetTimeBased( );
    }

    virtual bool Damage_IsTimeBased( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_IsTimeBased: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_IsTimeBased( iDmgType ) of Class: C_MultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_IsTimeBased = this->get_override( "Damage_IsTimeBased" );
        if( func_Damage_IsTimeBased.ptr() != Py_None )
            try {
                return func_Damage_IsTimeBased( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_IsTimeBased( iDmgType );
            }
        else
            return this->C_MultiplayRules::Damage_IsTimeBased( iDmgType );
    }
    
    bool default_Damage_IsTimeBased( int iDmgType ) {
        return C_MultiplayRules::Damage_IsTimeBased( iDmgType );
    }

    virtual bool Damage_NoPhysicsForce( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_NoPhysicsForce: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_NoPhysicsForce( iDmgType ) of Class: C_MultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_NoPhysicsForce = this->get_override( "Damage_NoPhysicsForce" );
        if( func_Damage_NoPhysicsForce.ptr() != Py_None )
            try {
                return func_Damage_NoPhysicsForce( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_NoPhysicsForce( iDmgType );
            }
        else
            return this->C_MultiplayRules::Damage_NoPhysicsForce( iDmgType );
    }
    
    bool default_Damage_NoPhysicsForce( int iDmgType ) {
        return C_MultiplayRules::Damage_NoPhysicsForce( iDmgType );
    }

    virtual bool Damage_ShouldGibCorpse( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_ShouldGibCorpse: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_ShouldGibCorpse( iDmgType ) of Class: C_MultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_ShouldGibCorpse = this->get_override( "Damage_ShouldGibCorpse" );
        if( func_Damage_ShouldGibCorpse.ptr() != Py_None )
            try {
                return func_Damage_ShouldGibCorpse( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_ShouldGibCorpse( iDmgType );
            }
        else
            return this->C_MultiplayRules::Damage_ShouldGibCorpse( iDmgType );
    }
    
    bool default_Damage_ShouldGibCorpse( int iDmgType ) {
        return C_MultiplayRules::Damage_ShouldGibCorpse( iDmgType );
    }

    virtual bool Damage_ShouldNotBleed( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_ShouldNotBleed: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_ShouldNotBleed( iDmgType ) of Class: C_MultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_ShouldNotBleed = this->get_override( "Damage_ShouldNotBleed" );
        if( func_Damage_ShouldNotBleed.ptr() != Py_None )
            try {
                return func_Damage_ShouldNotBleed( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_ShouldNotBleed( iDmgType );
            }
        else
            return this->C_MultiplayRules::Damage_ShouldNotBleed( iDmgType );
    }
    
    bool default_Damage_ShouldNotBleed( int iDmgType ) {
        return C_MultiplayRules::Damage_ShouldNotBleed( iDmgType );
    }

    virtual bool Damage_ShowOnHUD( int iDmgType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Damage_ShowOnHUD: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Damage_ShowOnHUD( iDmgType ) of Class: C_MultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Damage_ShowOnHUD = this->get_override( "Damage_ShowOnHUD" );
        if( func_Damage_ShowOnHUD.ptr() != Py_None )
            try {
                return func_Damage_ShowOnHUD( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_ShowOnHUD( iDmgType );
            }
        else
            return this->C_MultiplayRules::Damage_ShowOnHUD( iDmgType );
    }
    
    bool default_Damage_ShowOnHUD( int iDmgType ) {
        return C_MultiplayRules::Damage_ShowOnHUD( iDmgType );
    }

    virtual int DefaultFOV(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "DefaultFOV: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling DefaultFOV(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_DefaultFOV = this->get_override( "DefaultFOV" );
        if( func_DefaultFOV.ptr() != Py_None )
            try {
                return func_DefaultFOV(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::DefaultFOV(  );
            }
        else
            return this->C_GameRules::DefaultFOV(  );
    }
    
    int default_DefaultFOV(  ) {
        return C_GameRules::DefaultFOV( );
    }

    virtual int GetCaptureValueForPlayer( ::C_BasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetCaptureValueForPlayer: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetCaptureValueForPlayer( boost::python::ptr(pPlayer) ) of Class: C_TeamplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetCaptureValueForPlayer = this->get_override( "GetCaptureValueForPlayer" );
        if( func_GetCaptureValueForPlayer.ptr() != Py_None )
            try {
                return func_GetCaptureValueForPlayer( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_TeamplayRules::GetCaptureValueForPlayer( boost::python::ptr(pPlayer) );
            }
        else
            return this->C_TeamplayRules::GetCaptureValueForPlayer( boost::python::ptr(pPlayer) );
    }
    
    int default_GetCaptureValueForPlayer( ::C_BasePlayer * pPlayer ) {
        return C_TeamplayRules::GetCaptureValueForPlayer( boost::python::ptr(pPlayer) );
    }

    virtual float GetDamageMultiplier(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetDamageMultiplier: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetDamageMultiplier(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetDamageMultiplier = this->get_override( "GetDamageMultiplier" );
        if( func_GetDamageMultiplier.ptr() != Py_None )
            try {
                return func_GetDamageMultiplier(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::GetDamageMultiplier(  );
            }
        else
            return this->C_GameRules::GetDamageMultiplier(  );
    }
    
    float default_GetDamageMultiplier(  ) {
        return C_GameRules::GetDamageMultiplier( );
    }

    virtual int GetGameType(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetGameType: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetGameType(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetGameType = this->get_override( "GetGameType" );
        if( func_GetGameType.ptr() != Py_None )
            try {
                return func_GetGameType(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::GetGameType(  );
            }
        else
            return this->C_GameRules::GetGameType(  );
    }
    
    int default_GetGameType(  ) {
        return C_GameRules::GetGameType( );
    }

    virtual char const * GetGameTypeName(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetGameTypeName: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetGameTypeName(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetGameTypeName = this->get_override( "GetGameTypeName" );
        if( func_GetGameTypeName.ptr() != Py_None )
            try {
                return func_GetGameTypeName(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::GetGameTypeName(  );
            }
        else
            return this->C_GameRules::GetGameTypeName(  );
    }
    
    char const * default_GetGameTypeName(  ) {
        return C_GameRules::GetGameTypeName( );
    }

    virtual ::C_BaseCombatWeapon * GetNextBestWeapon( ::C_BaseCombatCharacter * pPlayer, ::C_BaseCombatWeapon * pCurrentWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetNextBestWeapon: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetNextBestWeapon = this->get_override( "GetNextBestWeapon" );
        if( func_GetNextBestWeapon.ptr() != Py_None )
            try {
                return func_GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
            }
        else
            return this->C_GameRules::GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
    }
    
    ::C_BaseCombatWeapon * default_GetNextBestWeapon( ::C_BaseCombatCharacter * pPlayer, ::C_BaseCombatWeapon * pCurrentWeapon ) {
        return C_GameRules::GetNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
    }

    virtual bool InRoundRestart(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "InRoundRestart: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling InRoundRestart(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_InRoundRestart = this->get_override( "InRoundRestart" );
        if( func_InRoundRestart.ptr() != Py_None )
            try {
                return func_InRoundRestart(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::InRoundRestart(  );
            }
        else
            return this->C_GameRules::InRoundRestart(  );
    }
    
    bool default_InRoundRestart(  ) {
        return C_GameRules::InRoundRestart( );
    }

    virtual bool Init(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Init: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Init(  ) of Class: C_MultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Init = this->get_override( "Init" );
        if( func_Init.ptr() != Py_None )
            try {
                return func_Init(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Init(  );
            }
        else
            return this->C_MultiplayRules::Init(  );
    }
    
    bool default_Init(  ) {
        return C_MultiplayRules::Init( );
    }

    virtual void InitGamerules(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "InitGamerules: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling InitGamerules(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_InitGamerules = this->get_override( "InitGamerules" );
        if( func_InitGamerules.ptr() != Py_None )
            try {
                func_InitGamerules(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::InitGamerules(  );
            }
        else
            this->C_GameRules::InitGamerules(  );
    }
    
    void default_InitGamerules(  ) {
        C_GameRules::InitGamerules( );
    }

    virtual bool IsBonusChallengeTimeBased(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsBonusChallengeTimeBased: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsBonusChallengeTimeBased(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsBonusChallengeTimeBased = this->get_override( "IsBonusChallengeTimeBased" );
        if( func_IsBonusChallengeTimeBased.ptr() != Py_None )
            try {
                return func_IsBonusChallengeTimeBased(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::IsBonusChallengeTimeBased(  );
            }
        else
            return this->C_GameRules::IsBonusChallengeTimeBased(  );
    }
    
    bool default_IsBonusChallengeTimeBased(  ) {
        return C_GameRules::IsBonusChallengeTimeBased( );
    }

    virtual bool IsHolidayActive( int eHoliday ) const  {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsHolidayActive: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsHolidayActive( eHoliday ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsHolidayActive = this->get_override( "IsHolidayActive" );
        if( func_IsHolidayActive.ptr() != Py_None )
            try {
                return func_IsHolidayActive( eHoliday );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::IsHolidayActive( eHoliday );
            }
        else
            return this->C_GameRules::IsHolidayActive( eHoliday );
    }
    
    bool default_IsHolidayActive( int eHoliday ) const  {
        return C_GameRules::IsHolidayActive( eHoliday );
    }

    virtual bool IsLocalPlayer( int nEntIndex ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsLocalPlayer: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsLocalPlayer( nEntIndex ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsLocalPlayer = this->get_override( "IsLocalPlayer" );
        if( func_IsLocalPlayer.ptr() != Py_None )
            try {
                return func_IsLocalPlayer( nEntIndex );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::IsLocalPlayer( nEntIndex );
            }
        else
            return this->C_GameRules::IsLocalPlayer( nEntIndex );
    }
    
    bool default_IsLocalPlayer( int nEntIndex ) {
        return C_GameRules::IsLocalPlayer( nEntIndex );
    }

    virtual bool IsMultiplayer(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsMultiplayer: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsMultiplayer(  ) of Class: C_MultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsMultiplayer = this->get_override( "IsMultiplayer" );
        if( func_IsMultiplayer.ptr() != Py_None )
            try {
                return func_IsMultiplayer(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::IsMultiplayer(  );
            }
        else
            return this->C_MultiplayRules::IsMultiplayer(  );
    }
    
    bool default_IsMultiplayer(  ) {
        return C_MultiplayRules::IsMultiplayer( );
    }

    virtual void ModifySentChat( char * pBuf, int iBufSize ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ModifySentChat: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ModifySentChat( pBuf, iBufSize ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ModifySentChat = this->get_override( "ModifySentChat" );
        if( func_ModifySentChat.ptr() != Py_None )
            try {
                func_ModifySentChat( pBuf, iBufSize );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::ModifySentChat( pBuf, iBufSize );
            }
        else
            this->C_GameRules::ModifySentChat( pBuf, iBufSize );
    }
    
    void default_ModifySentChat( char * pBuf, int iBufSize ) {
        C_GameRules::ModifySentChat( pBuf, iBufSize );
    }

    virtual char const * Name(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Name: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Name(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Name = this->get_override( "Name" );
        if( func_Name.ptr() != Py_None )
            try {
                return func_Name(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::Name(  );
            }
        else
            return this->C_GameRules::Name(  );
    }
    
    char const * default_Name(  ) {
        return C_GameRules::Name( );
    }

    virtual void OnFileReceived( char const * fileName, unsigned int transferID ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnFileReceived: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnFileReceived( fileName, transferID ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnFileReceived = this->get_override( "OnFileReceived" );
        if( func_OnFileReceived.ptr() != Py_None )
            try {
                func_OnFileReceived( fileName, transferID );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::OnFileReceived( fileName, transferID );
            }
        else
            this->C_GameRules::OnFileReceived( fileName, transferID );
    }
    
    void default_OnFileReceived( char const * fileName, unsigned int transferID ) {
        C_GameRules::OnFileReceived( fileName, transferID );
    }

    virtual bool PlayerMayBlockPoint( ::C_BasePlayer * pPlayer, int iPointIndex, char * pszReason=0, int iMaxReasonLength=0 ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PlayerMayBlockPoint: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PlayerMayBlockPoint( boost::python::ptr(pPlayer), iPointIndex, pszReason, iMaxReasonLength ) of Class: C_TeamplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PlayerMayBlockPoint = this->get_override( "PlayerMayBlockPoint" );
        if( func_PlayerMayBlockPoint.ptr() != Py_None )
            try {
                return func_PlayerMayBlockPoint( boost::python::ptr(pPlayer), iPointIndex, pszReason, iMaxReasonLength );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_TeamplayRules::PlayerMayBlockPoint( boost::python::ptr(pPlayer), iPointIndex, pszReason, iMaxReasonLength );
            }
        else
            return this->C_TeamplayRules::PlayerMayBlockPoint( boost::python::ptr(pPlayer), iPointIndex, pszReason, iMaxReasonLength );
    }
    
    bool default_PlayerMayBlockPoint( ::C_BasePlayer * pPlayer, int iPointIndex, char * pszReason=0, int iMaxReasonLength=0 ) {
        return C_TeamplayRules::PlayerMayBlockPoint( boost::python::ptr(pPlayer), iPointIndex, pszReason, iMaxReasonLength );
    }

    virtual bool PlayerMayCapturePoint( ::C_BasePlayer * pPlayer, int iPointIndex, char * pszReason=0, int iMaxReasonLength=0 ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PlayerMayCapturePoint: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PlayerMayCapturePoint( boost::python::ptr(pPlayer), iPointIndex, pszReason, iMaxReasonLength ) of Class: C_TeamplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PlayerMayCapturePoint = this->get_override( "PlayerMayCapturePoint" );
        if( func_PlayerMayCapturePoint.ptr() != Py_None )
            try {
                return func_PlayerMayCapturePoint( boost::python::ptr(pPlayer), iPointIndex, pszReason, iMaxReasonLength );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_TeamplayRules::PlayerMayCapturePoint( boost::python::ptr(pPlayer), iPointIndex, pszReason, iMaxReasonLength );
            }
        else
            return this->C_TeamplayRules::PlayerMayCapturePoint( boost::python::ptr(pPlayer), iPointIndex, pszReason, iMaxReasonLength );
    }
    
    bool default_PlayerMayCapturePoint( ::C_BasePlayer * pPlayer, int iPointIndex, char * pszReason=0, int iMaxReasonLength=0 ) {
        return C_TeamplayRules::PlayerMayCapturePoint( boost::python::ptr(pPlayer), iPointIndex, pszReason, iMaxReasonLength );
    }

    virtual bool PointsMayBeCaptured(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PointsMayBeCaptured: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PointsMayBeCaptured(  ) of Class: C_TeamplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PointsMayBeCaptured = this->get_override( "PointsMayBeCaptured" );
        if( func_PointsMayBeCaptured.ptr() != Py_None )
            try {
                return func_PointsMayBeCaptured(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_TeamplayRules::PointsMayBeCaptured(  );
            }
        else
            return this->C_TeamplayRules::PointsMayBeCaptured(  );
    }
    
    bool default_PointsMayBeCaptured(  ) {
        return C_TeamplayRules::PointsMayBeCaptured( );
    }

    virtual void SetLastCapPointChanged( int iIndex ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SetLastCapPointChanged: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SetLastCapPointChanged( iIndex ) of Class: C_TeamplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SetLastCapPointChanged = this->get_override( "SetLastCapPointChanged" );
        if( func_SetLastCapPointChanged.ptr() != Py_None )
            try {
                func_SetLastCapPointChanged( iIndex );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_TeamplayRules::SetLastCapPointChanged( iIndex );
            }
        else
            this->C_TeamplayRules::SetLastCapPointChanged( iIndex );
    }
    
    void default_SetLastCapPointChanged( int iIndex ) {
        C_TeamplayRules::SetLastCapPointChanged( iIndex );
    }

    virtual bool ShouldDrawHeadLabels(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShouldDrawHeadLabels: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShouldDrawHeadLabels(  ) of Class: C_MultiplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShouldDrawHeadLabels = this->get_override( "ShouldDrawHeadLabels" );
        if( func_ShouldDrawHeadLabels.ptr() != Py_None )
            try {
                return func_ShouldDrawHeadLabels(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::ShouldDrawHeadLabels(  );
            }
        else
            return this->C_MultiplayRules::ShouldDrawHeadLabels(  );
    }
    
    bool default_ShouldDrawHeadLabels(  ) {
        return C_MultiplayRules::ShouldDrawHeadLabels( );
    }

    virtual bool ShouldWarnOfAbandonOnQuit(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShouldWarnOfAbandonOnQuit: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShouldWarnOfAbandonOnQuit(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShouldWarnOfAbandonOnQuit = this->get_override( "ShouldWarnOfAbandonOnQuit" );
        if( func_ShouldWarnOfAbandonOnQuit.ptr() != Py_None )
            try {
                return func_ShouldWarnOfAbandonOnQuit(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::ShouldWarnOfAbandonOnQuit(  );
            }
        else
            return this->C_GameRules::ShouldWarnOfAbandonOnQuit(  );
    }
    
    bool default_ShouldWarnOfAbandonOnQuit(  ) {
        return C_GameRules::ShouldWarnOfAbandonOnQuit( );
    }

    virtual void ShutdownGamerules(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShutdownGamerules: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShutdownGamerules(  ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShutdownGamerules = this->get_override( "ShutdownGamerules" );
        if( func_ShutdownGamerules.ptr() != Py_None )
            try {
                func_ShutdownGamerules(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::ShutdownGamerules(  );
            }
        else
            this->C_GameRules::ShutdownGamerules(  );
    }
    
    void default_ShutdownGamerules(  ) {
        C_GameRules::ShutdownGamerules( );
    }

    virtual bool SwitchToNextBestWeapon( ::C_BaseCombatCharacter * pPlayer, ::C_BaseCombatWeapon * pCurrentWeapon ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SwitchToNextBestWeapon: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SwitchToNextBestWeapon = this->get_override( "SwitchToNextBestWeapon" );
        if( func_SwitchToNextBestWeapon.ptr() != Py_None )
            try {
                return func_SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
            }
        else
            return this->C_GameRules::SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
    }
    
    bool default_SwitchToNextBestWeapon( ::C_BaseCombatCharacter * pPlayer, ::C_BaseCombatWeapon * pCurrentWeapon ) {
        return C_GameRules::SwitchToNextBestWeapon( boost::python::ptr(pPlayer), boost::python::ptr(pCurrentWeapon) );
    }

    virtual bool TeamMayCapturePoint( int iTeam, int iPointIndex ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "TeamMayCapturePoint: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling TeamMayCapturePoint( iTeam, iPointIndex ) of Class: C_TeamplayRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_TeamMayCapturePoint = this->get_override( "TeamMayCapturePoint" );
        if( func_TeamMayCapturePoint.ptr() != Py_None )
            try {
                return func_TeamMayCapturePoint( iTeam, iPointIndex );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_TeamplayRules::TeamMayCapturePoint( iTeam, iPointIndex );
            }
        else
            return this->C_TeamplayRules::TeamMayCapturePoint( iTeam, iPointIndex );
    }
    
    bool default_TeamMayCapturePoint( int iTeam, int iPointIndex ) {
        return C_TeamplayRules::TeamMayCapturePoint( iTeam, iPointIndex );
    }

    virtual char const * TranslateEffectForVisionFilter( char const * pchEffectType, char const * pchEffectName ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "TranslateEffectForVisionFilter: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling TranslateEffectForVisionFilter( pchEffectType, pchEffectName ) of Class: C_GameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_TranslateEffectForVisionFilter = this->get_override( "TranslateEffectForVisionFilter" );
        if( func_TranslateEffectForVisionFilter.ptr() != Py_None )
            try {
                return func_TranslateEffectForVisionFilter( pchEffectType, pchEffectName );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::TranslateEffectForVisionFilter( pchEffectType, pchEffectName );
            }
        else
            return this->C_GameRules::TranslateEffectForVisionFilter( pchEffectType, pchEffectName );
    }
    
    char const * default_TranslateEffectForVisionFilter( char const * pchEffectType, char const * pchEffectName ) {
        return C_GameRules::TranslateEffectForVisionFilter( pchEffectType, pchEffectName );
    }

    virtual PyObject *GetPySelf() const { return boost::python::detail::wrapper_base_::get_owner(*this); }

};

void register_CHL2MPRules_class(){

    bp::class_< C_HL2MPRules_wrapper, bp::bases< C_TeamplayRules >, boost::noncopyable >( "CHL2MPRules", bp::no_init )    
        .def( bp::init< >() )    
        .def( 
            "CheckGameOver"
            , (bool ( ::C_HL2MPRules::* )(  ) )( &::C_HL2MPRules::CheckGameOver ) )    
        .def( 
            "ClientCommand"
            , (bool ( ::C_HL2MPRules::* )( ::C_BaseEntity *,::CCommand const & ) )(&::C_HL2MPRules::ClientCommand)
            , (bool ( C_HL2MPRules_wrapper::* )( ::C_BaseEntity *,::CCommand const & ) )(&C_HL2MPRules_wrapper::default_ClientCommand)
            , ( bp::arg("pEdict"), bp::arg("args") ) )    
        .def( 
            "ClientDisconnected"
            , (void ( ::C_HL2MPRules::* )( ::edict_t * ) )(&::C_HL2MPRules::ClientDisconnected)
            , (void ( C_HL2MPRules_wrapper::* )( ::edict_t * ) )(&C_HL2MPRules_wrapper::default_ClientDisconnected)
            , ( bp::arg("pClient") ) )    
        .def( 
            "ClientSettingsChanged"
            , (void ( ::C_HL2MPRules::* )( ::C_BasePlayer * ) )(&::C_HL2MPRules::ClientSettingsChanged)
            , (void ( C_HL2MPRules_wrapper::* )( ::C_BasePlayer * ) )(&C_HL2MPRules_wrapper::default_ClientSettingsChanged)
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "CreateStandardEntities"
            , (void ( ::C_HL2MPRules::* )(  ) )(&::C_HL2MPRules::CreateStandardEntities)
            , (void ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_CreateStandardEntities) )    
        .def( 
            "DeathNotice"
            , (void ( ::C_HL2MPRules::* )( ::C_BasePlayer *,::CTakeDamageInfo const & ) )(&::C_HL2MPRules::DeathNotice)
            , (void ( C_HL2MPRules_wrapper::* )( ::C_BasePlayer *,::CTakeDamageInfo const & ) )(&C_HL2MPRules_wrapper::default_DeathNotice)
            , ( bp::arg("pVictim"), bp::arg("info") ) )    
        .def( 
            "FlWeaponRespawnTime"
            , (float ( ::C_HL2MPRules::* )( ::C_BaseCombatWeapon * ) )(&::C_HL2MPRules::FlWeaponRespawnTime)
            , (float ( C_HL2MPRules_wrapper::* )( ::C_BaseCombatWeapon * ) )(&C_HL2MPRules_wrapper::default_FlWeaponRespawnTime)
            , ( bp::arg("pWeapon") ) )    
        .def( 
            "FlWeaponTryRespawn"
            , (float ( ::C_HL2MPRules::* )( ::C_BaseCombatWeapon * ) )(&::C_HL2MPRules::FlWeaponTryRespawn)
            , (float ( C_HL2MPRules_wrapper::* )( ::C_BaseCombatWeapon * ) )(&C_HL2MPRules_wrapper::default_FlWeaponTryRespawn)
            , ( bp::arg("pWeapon") ) )    
        .def( 
            "GetGameDescription"
            , (char const * ( ::C_HL2MPRules::* )(  ) )(&::C_HL2MPRules::GetGameDescription)
            , (char const * ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_GetGameDescription) )    
        .def( 
            "GetMapRemainingTime"
            , (float ( ::C_HL2MPRules::* )(  ) )( &::C_HL2MPRules::GetMapRemainingTime ) )    
        .def( 
            "GoToIntermission"
            , (void ( ::C_HL2MPRules::* )(  ) )(&::C_HL2MPRules::GoToIntermission)
            , (void ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_GoToIntermission) )    
        .def( 
            "IsConnectedUserInfoChangeAllowed"
            , (bool ( ::C_HL2MPRules::* )( ::C_BasePlayer * ) )(&::C_HL2MPRules::IsConnectedUserInfoChangeAllowed)
            , (bool ( C_HL2MPRules_wrapper::* )( ::C_BasePlayer * ) )(&C_HL2MPRules_wrapper::default_IsConnectedUserInfoChangeAllowed)
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "IsIntermission"
            , (bool ( ::C_HL2MPRules::* )(  ) )( &::C_HL2MPRules::IsIntermission ) )    
        .def( 
            "IsTeamplay"
            , (bool ( ::C_HL2MPRules::* )(  ) )( &::C_HL2MPRules::IsTeamplay ) )    
        .def( 
            "PlayerKilled"
            , (void ( ::C_HL2MPRules::* )( ::C_BasePlayer *,::CTakeDamageInfo const & ) )( &::C_HL2MPRules::PlayerKilled )
            , ( bp::arg("pVictim"), bp::arg("info") ) )    
        .def( 
            "PlayerRelationship"
            , (int ( ::C_HL2MPRules::* )( ::C_BaseEntity *,::C_BaseEntity * ) )(&::C_HL2MPRules::PlayerRelationship)
            , (int ( C_HL2MPRules_wrapper::* )( ::C_BaseEntity *,::C_BaseEntity * ) )(&C_HL2MPRules_wrapper::default_PlayerRelationship)
            , ( bp::arg("pPlayer"), bp::arg("pTarget") ) )    
        .def( 
            "Precache"
            , (void ( ::C_HL2MPRules::* )(  ) )(&::C_HL2MPRules::Precache)
            , (void ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_Precache) )    
        .def( 
            "ShouldCollide"
            , (bool ( ::C_HL2MPRules::* )( int,int ) )( &::C_HL2MPRules::ShouldCollide )
            , ( bp::arg("collisionGroup0"), bp::arg("collisionGroup1") ) )    
        .def( 
            "Think"
            , (void ( ::C_HL2MPRules::* )(  ) )(&::C_HL2MPRules::Think)
            , (void ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_Think) )    
        .def( 
            "VecWeaponRespawnSpot"
            , (::Vector ( ::C_HL2MPRules::* )( ::C_BaseCombatWeapon * ) )(&::C_HL2MPRules::VecWeaponRespawnSpot)
            , (::Vector ( C_HL2MPRules_wrapper::* )( ::C_BaseCombatWeapon * ) )(&C_HL2MPRules_wrapper::default_VecWeaponRespawnSpot)
            , ( bp::arg("pWeapon") ) )    
        .def( 
            "WeaponShouldRespawn"
            , (int ( ::C_HL2MPRules::* )( ::C_BaseCombatWeapon * ) )(&::C_HL2MPRules::WeaponShouldRespawn)
            , (int ( C_HL2MPRules_wrapper::* )( ::C_BaseCombatWeapon * ) )(&C_HL2MPRules_wrapper::default_WeaponShouldRespawn)
            , ( bp::arg("pWeapon") ) )    
        .def( 
            "AllowMapParticleEffect"
            , (bool ( ::C_GameRules::* )( char const * ) )(&::C_GameRules::AllowMapParticleEffect)
            , (bool ( C_HL2MPRules_wrapper::* )( char const * ) )(&C_HL2MPRules_wrapper::default_AllowMapParticleEffect)
            , ( bp::arg("pszParticleEffect") ) )    
        .def( 
            "AllowMapVisionFilterShaders"
            , (bool ( ::C_GameRules::* )(  ) )(&::C_GameRules::AllowMapVisionFilterShaders)
            , (bool ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_AllowMapVisionFilterShaders) )    
        .def( 
            "AllowThirdPersonCamera"
            , (bool ( ::C_GameRules::* )(  ) )(&::C_GameRules::AllowThirdPersonCamera)
            , (bool ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_AllowThirdPersonCamera) )    
        .def( 
            "AllowWeatherParticles"
            , (bool ( ::C_GameRules::* )(  ) )(&::C_GameRules::AllowWeatherParticles)
            , (bool ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_AllowWeatherParticles) )    
        .def( 
            "ClientCommandKeyValues"
            , (void ( ::C_GameRules::* )( ::edict_t *,::KeyValues * ) )(&::C_GameRules::ClientCommandKeyValues)
            , (void ( C_HL2MPRules_wrapper::* )( ::edict_t *,::KeyValues * ) )(&C_HL2MPRules_wrapper::default_ClientCommandKeyValues)
            , ( bp::arg("pEntity"), bp::arg("pKeyValues") ) )    
        .def( 
            "ClientSpawned"
            , (void ( ::C_GameRules::* )( ::edict_t * ) )(&::C_GameRules::ClientSpawned)
            , (void ( C_HL2MPRules_wrapper::* )( ::edict_t * ) )(&C_HL2MPRules_wrapper::default_ClientSpawned)
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "Damage_GetNoPhysicsForce"
            , (int ( ::C_MultiplayRules::* )(  ) )(&::C_MultiplayRules::Damage_GetNoPhysicsForce)
            , (int ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_Damage_GetNoPhysicsForce) )    
        .def( 
            "Damage_GetShouldGibCorpse"
            , (int ( ::C_MultiplayRules::* )(  ) )(&::C_MultiplayRules::Damage_GetShouldGibCorpse)
            , (int ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_Damage_GetShouldGibCorpse) )    
        .def( 
            "Damage_GetShouldNotBleed"
            , (int ( ::C_MultiplayRules::* )(  ) )(&::C_MultiplayRules::Damage_GetShouldNotBleed)
            , (int ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_Damage_GetShouldNotBleed) )    
        .def( 
            "Damage_GetShowOnHud"
            , (int ( ::C_MultiplayRules::* )(  ) )(&::C_MultiplayRules::Damage_GetShowOnHud)
            , (int ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_Damage_GetShowOnHud) )    
        .def( 
            "Damage_GetTimeBased"
            , (int ( ::C_MultiplayRules::* )(  ) )(&::C_MultiplayRules::Damage_GetTimeBased)
            , (int ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_Damage_GetTimeBased) )    
        .def( 
            "Damage_IsTimeBased"
            , (bool ( ::C_MultiplayRules::* )( int ) )(&::C_MultiplayRules::Damage_IsTimeBased)
            , (bool ( C_HL2MPRules_wrapper::* )( int ) )(&C_HL2MPRules_wrapper::default_Damage_IsTimeBased)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_NoPhysicsForce"
            , (bool ( ::C_MultiplayRules::* )( int ) )(&::C_MultiplayRules::Damage_NoPhysicsForce)
            , (bool ( C_HL2MPRules_wrapper::* )( int ) )(&C_HL2MPRules_wrapper::default_Damage_NoPhysicsForce)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_ShouldGibCorpse"
            , (bool ( ::C_MultiplayRules::* )( int ) )(&::C_MultiplayRules::Damage_ShouldGibCorpse)
            , (bool ( C_HL2MPRules_wrapper::* )( int ) )(&C_HL2MPRules_wrapper::default_Damage_ShouldGibCorpse)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_ShouldNotBleed"
            , (bool ( ::C_MultiplayRules::* )( int ) )(&::C_MultiplayRules::Damage_ShouldNotBleed)
            , (bool ( C_HL2MPRules_wrapper::* )( int ) )(&C_HL2MPRules_wrapper::default_Damage_ShouldNotBleed)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_ShowOnHUD"
            , (bool ( ::C_MultiplayRules::* )( int ) )(&::C_MultiplayRules::Damage_ShowOnHUD)
            , (bool ( C_HL2MPRules_wrapper::* )( int ) )(&C_HL2MPRules_wrapper::default_Damage_ShowOnHUD)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "DefaultFOV"
            , (int ( ::C_GameRules::* )(  ) )(&::C_GameRules::DefaultFOV)
            , (int ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_DefaultFOV) )    
        .def( 
            "GetCaptureValueForPlayer"
            , (int ( ::C_TeamplayRules::* )( ::C_BasePlayer * ) )(&::C_TeamplayRules::GetCaptureValueForPlayer)
            , (int ( C_HL2MPRules_wrapper::* )( ::C_BasePlayer * ) )(&C_HL2MPRules_wrapper::default_GetCaptureValueForPlayer)
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "GetDamageMultiplier"
            , (float ( ::C_GameRules::* )(  ) )(&::C_GameRules::GetDamageMultiplier)
            , (float ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_GetDamageMultiplier) )    
        .def( 
            "GetGameType"
            , (int ( ::C_GameRules::* )(  ) )(&::C_GameRules::GetGameType)
            , (int ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_GetGameType) )    
        .def( 
            "GetGameTypeName"
            , (char const * ( ::C_GameRules::* )(  ) )(&::C_GameRules::GetGameTypeName)
            , (char const * ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_GetGameTypeName) )    
        .def( 
            "GetNextBestWeapon"
            , (::C_BaseCombatWeapon * ( ::C_GameRules::* )( ::C_BaseCombatCharacter *,::C_BaseCombatWeapon * ) )(&::C_GameRules::GetNextBestWeapon)
            , (::C_BaseCombatWeapon * ( C_HL2MPRules_wrapper::* )( ::C_BaseCombatCharacter *,::C_BaseCombatWeapon * ) )(&C_HL2MPRules_wrapper::default_GetNextBestWeapon)
            , ( bp::arg("pPlayer"), bp::arg("pCurrentWeapon") )
            , bp::return_value_policy< bp::return_by_value >() )    
        .def( 
            "InRoundRestart"
            , (bool ( ::C_GameRules::* )(  ) )(&::C_GameRules::InRoundRestart)
            , (bool ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_InRoundRestart) )    
        .def( 
            "Init"
            , (bool ( ::C_MultiplayRules::* )(  ) )(&::C_MultiplayRules::Init)
            , (bool ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_Init) )    
        .def( 
            "InitGamerules"
            , (void ( ::C_GameRules::* )(  ) )(&::C_GameRules::InitGamerules)
            , (void ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_InitGamerules) )    
        .def( 
            "IsBonusChallengeTimeBased"
            , (bool ( ::C_GameRules::* )(  ) )(&::C_GameRules::IsBonusChallengeTimeBased)
            , (bool ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_IsBonusChallengeTimeBased) )    
        .def( 
            "IsHolidayActive"
            , (bool ( ::C_GameRules::* )( int ) const)(&::C_GameRules::IsHolidayActive)
            , (bool ( C_HL2MPRules_wrapper::* )( int ) const)(&C_HL2MPRules_wrapper::default_IsHolidayActive)
            , ( bp::arg("eHoliday") ) )    
        .def( 
            "IsLocalPlayer"
            , (bool ( ::C_GameRules::* )( int ) )(&::C_GameRules::IsLocalPlayer)
            , (bool ( C_HL2MPRules_wrapper::* )( int ) )(&C_HL2MPRules_wrapper::default_IsLocalPlayer)
            , ( bp::arg("nEntIndex") ) )    
        .def( 
            "IsMultiplayer"
            , (bool ( ::C_MultiplayRules::* )(  ) )(&::C_MultiplayRules::IsMultiplayer)
            , (bool ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_IsMultiplayer) )    
        .def( 
            "ModifySentChat"
            , (void ( ::C_GameRules::* )( char *,int ) )(&::C_GameRules::ModifySentChat)
            , (void ( C_HL2MPRules_wrapper::* )( char *,int ) )(&C_HL2MPRules_wrapper::default_ModifySentChat)
            , ( bp::arg("pBuf"), bp::arg("iBufSize") ) )    
        .def( 
            "Name"
            , (char const * ( ::C_GameRules::* )(  ) )(&::C_GameRules::Name)
            , (char const * ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_Name) )    
        .def( 
            "OnFileReceived"
            , (void ( ::C_GameRules::* )( char const *,unsigned int ) )(&::C_GameRules::OnFileReceived)
            , (void ( C_HL2MPRules_wrapper::* )( char const *,unsigned int ) )(&C_HL2MPRules_wrapper::default_OnFileReceived)
            , ( bp::arg("fileName"), bp::arg("transferID") ) )    
        .def( 
            "PlayerMayBlockPoint"
            , (bool ( ::C_TeamplayRules::* )( ::C_BasePlayer *,int,char *,int ) )(&::C_TeamplayRules::PlayerMayBlockPoint)
            , (bool ( C_HL2MPRules_wrapper::* )( ::C_BasePlayer *,int,char *,int ) )(&C_HL2MPRules_wrapper::default_PlayerMayBlockPoint)
            , ( bp::arg("pPlayer"), bp::arg("iPointIndex"), bp::arg("pszReason")=bp::object(), bp::arg("iMaxReasonLength")=(int)(0) ) )    
        .def( 
            "PlayerMayCapturePoint"
            , (bool ( ::C_TeamplayRules::* )( ::C_BasePlayer *,int,char *,int ) )(&::C_TeamplayRules::PlayerMayCapturePoint)
            , (bool ( C_HL2MPRules_wrapper::* )( ::C_BasePlayer *,int,char *,int ) )(&C_HL2MPRules_wrapper::default_PlayerMayCapturePoint)
            , ( bp::arg("pPlayer"), bp::arg("iPointIndex"), bp::arg("pszReason")=bp::object(), bp::arg("iMaxReasonLength")=(int)(0) ) )    
        .def( 
            "PointsMayBeCaptured"
            , (bool ( ::C_TeamplayRules::* )(  ) )(&::C_TeamplayRules::PointsMayBeCaptured)
            , (bool ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_PointsMayBeCaptured) )    
        .def( 
            "SetLastCapPointChanged"
            , (void ( ::C_TeamplayRules::* )( int ) )(&::C_TeamplayRules::SetLastCapPointChanged)
            , (void ( C_HL2MPRules_wrapper::* )( int ) )(&C_HL2MPRules_wrapper::default_SetLastCapPointChanged)
            , ( bp::arg("iIndex") ) )    
        .def( 
            "ShouldDrawHeadLabels"
            , (bool ( ::C_MultiplayRules::* )(  ) )(&::C_MultiplayRules::ShouldDrawHeadLabels)
            , (bool ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_ShouldDrawHeadLabels) )    
        .def( 
            "ShouldWarnOfAbandonOnQuit"
            , (bool ( ::C_GameRules::* )(  ) )(&::C_GameRules::ShouldWarnOfAbandonOnQuit)
            , (bool ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_ShouldWarnOfAbandonOnQuit) )    
        .def( 
            "ShutdownGamerules"
            , (void ( ::C_GameRules::* )(  ) )(&::C_GameRules::ShutdownGamerules)
            , (void ( C_HL2MPRules_wrapper::* )(  ) )(&C_HL2MPRules_wrapper::default_ShutdownGamerules) )    
        .def( 
            "SwitchToNextBestWeapon"
            , (bool ( ::C_GameRules::* )( ::C_BaseCombatCharacter *,::C_BaseCombatWeapon * ) )(&::C_GameRules::SwitchToNextBestWeapon)
            , (bool ( C_HL2MPRules_wrapper::* )( ::C_BaseCombatCharacter *,::C_BaseCombatWeapon * ) )(&C_HL2MPRules_wrapper::default_SwitchToNextBestWeapon)
            , ( bp::arg("pPlayer"), bp::arg("pCurrentWeapon") ) )    
        .def( 
            "TeamMayCapturePoint"
            , (bool ( ::C_TeamplayRules::* )( int,int ) )(&::C_TeamplayRules::TeamMayCapturePoint)
            , (bool ( C_HL2MPRules_wrapper::* )( int,int ) )(&C_HL2MPRules_wrapper::default_TeamMayCapturePoint)
            , ( bp::arg("iTeam"), bp::arg("iPointIndex") ) )    
        .def( 
            "TranslateEffectForVisionFilter"
            , (char const * ( ::C_GameRules::* )( char const *,char const * ) )(&::C_GameRules::TranslateEffectForVisionFilter)
            , (char const * ( C_HL2MPRules_wrapper::* )( char const *,char const * ) )(&C_HL2MPRules_wrapper::default_TranslateEffectForVisionFilter)
            , ( bp::arg("pchEffectType"), bp::arg("pchEffectName") ) );

}

